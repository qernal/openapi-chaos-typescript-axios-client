/**
 * Chaos
 * Central Management API - publicly exposed set of APIs for cloud resources
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: help@qernal.support
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import type { RequestArgs } from './base';
import { BaseAPI } from './base';
/**
 * API auth token
 */
export interface AuthToken {
    /**
     * Auth token uuid
     */
    'id': string;
    /**
     * User
     */
    'user_id': string;
    /**
     * Name of token
     */
    'name': string;
    /**
     * When the token expires
     */
    'expiry_at'?: string;
    /**
     * Combined token required for requesting an access token, this field is only returned once on creation or update (during regeneration).
     */
    'token'?: string;
    'date': ModelDate;
}
/**
 * API auth token create
 */
export interface AuthTokenBody {
    /**
     * Name of token
     */
    'name': string;
    /**
     * Token expiration duration in days. 0 - token will never expire
     */
    'expiry_duration': number;
}
/**
 * API auth token meta
 */
export interface AuthTokenMeta {
    'id': string;
    /**
     * User
     */
    'user_id': string;
    /**
     * Name of token
     */
    'name': string;
    'expiry_at'?: string;
    'date': ModelDate;
}
/**
 * API auth token patch
 */
export interface AuthTokenPatch {
    /**
     * Name of token
     */
    'name'?: string;
    /**
     * Token expiration duration in days. 0 - token will never expire
     */
    'expiry_duration'?: number;
}
/**
 * Bad request
 */
export interface BadRequestResponse {
    'message': string;
    'fields': BadRequestResponseFields;
}
export interface BadRequestResponseFields {
    'email'?: string;
}
/**
 * Conflict Response
 */
export interface ConflictResponse {
    'message': string;
}
/**
 * Deleted Response
 */
export interface DeletedResponse {
    'message': string;
}
/**
 * Function
 */
export interface Function {
    /**
     * ID of the function
     */
    'id': string;
    /**
     * ID of the project this function belongs to
     */
    'project_id': string;
    /**
     * Function spec version
     */
    'version': FunctionVersionEnum;
    /**
     * Name of the function
     */
    'name': string;
    /**
     * Description of what the function does
     */
    'description': string;
    /**
     * Path to container image
     */
    'image': string;
    /**
     * Function revision
     */
    'revision': string;
    'type': FunctionType;
    'size': FunctionSize;
    /**
     * Port the application runs on
     */
    'port': number;
    /**
     * The public route/path to this function, only applicable to http type functions
     */
    'routes'?: Array<FunctionRoute>;
    'scaling': FunctionScaling;
    /**
     * List of deployments for this function
     */
    'deployments': Array<FunctionDeployment>;
    /**
     * List of environment variables for secrets
     */
    'secrets': Array<FunctionEnv>;
    /**
     * Tags to limit deployment
     */
    'compliance': Array<FunctionCompliance>;
}
export declare const FunctionVersionEnum: {
    readonly _1_0_0: "1.0.0";
};
export type FunctionVersionEnum = typeof FunctionVersionEnum[keyof typeof FunctionVersionEnum];
/**
 * Function create body
 */
export interface FunctionBody {
    /**
     * ID of the project this function belongs to
     */
    'project_id': string;
    /**
     * Function spec version
     */
    'version': FunctionBodyVersionEnum;
    /**
     * Name of the function
     */
    'name': string;
    /**
     * Description of what the function does
     */
    'description': string;
    /**
     * Path to container image
     */
    'image': string;
    'type': FunctionType;
    'size': FunctionSize;
    /**
     * Port the application runs on
     */
    'port': number;
    /**
     * The public route/path to this function, only applicable to http type functions
     */
    'routes'?: Array<FunctionRoute>;
    'scaling': FunctionScaling;
    /**
     * List of deployments for this function
     */
    'deployments': Array<FunctionDeploymentBody>;
    /**
     * List of environment variables for secrets
     */
    'secrets': Array<FunctionEnv>;
    /**
     * Tags to limit deployment
     */
    'compliance': Array<FunctionCompliance>;
}
export declare const FunctionBodyVersionEnum: {
    readonly _1_0_0: "1.0.0";
};
export type FunctionBodyVersionEnum = typeof FunctionBodyVersionEnum[keyof typeof FunctionBodyVersionEnum];
/**
 * Tagged requirements for compliance; soc2 = SOC2 compliant data centers ipv6 = Function can work within an ipv6 *only* cluster
 */
export declare const FunctionCompliance: {
    readonly soc2: "soc2";
    readonly ipv6: "ipv6";
};
export type FunctionCompliance = typeof FunctionCompliance[keyof typeof FunctionCompliance];
export interface FunctionDeployment {
    /**
     * ID of the deployment
     */
    'id'?: string;
    'location': Location;
    'replicas': FunctionReplicas;
}
export interface FunctionDeploymentBody {
    'location': Location;
    'replicas': FunctionReplicas;
}
/**
 * Environment variable for function
 */
export interface FunctionEnv {
    /**
     * Key name
     */
    'name': string;
    /**
     * Reference for the secret, it\'s split up into 4 main parts; - [1] \"projects:\" - This references which resource type the secret is within - [2] \"0a6b9ff3-6807-4820-b94b-5e1d7efcdd93\" - The project UUID the secret is within - [3] \"MY_SECRET\" - The name of the secret - [4] \"0\" - The revision of the secret to use
     */
    'reference': string;
}
/**
 * Balancing logic
 */
export interface FunctionReplicas {
    /**
     * Minimum number of replicas to have
     */
    'min': number;
    /**
     * Maximum number of replicas to have
     */
    'max': number;
    'affinity': FunctionReplicasAffinity;
}
/**
 * Replica strategy
 */
export interface FunctionReplicasAffinity {
    /**
     * If there are > 1 replica, make sure they\'re on different clusters
     */
    'cluster': boolean;
    /**
     * If there are > 1 replica, make sure they\'re on different clouds
     */
    'cloud': boolean;
}
export interface FunctionRoute {
    /**
     * Can be a regular expression
     */
    'path': string;
    /**
     * HTTP Verb(s) for this function
     */
    'methods': Array<string>;
    /**
     * The route weight for consideration
     */
    'weight': number;
}
/**
 * Scaling logic
 */
export interface FunctionScaling {
    /**
     * CPU or Memory supported
     */
    'type': FunctionScalingTypeEnum;
    /**
     * For type to drop below before scale down
     */
    'low': number;
    /**
     * For type to go above before scale up
     */
    'high': number;
}
export declare const FunctionScalingTypeEnum: {
    readonly cpu: "cpu";
    readonly memory: "memory";
};
export type FunctionScalingTypeEnum = typeof FunctionScalingTypeEnum[keyof typeof FunctionScalingTypeEnum];
/**
 * Size of function, required CPU and Memory
 */
export interface FunctionSize {
    /**
     * CPU in 0.1 vCPU increments, for a whole vCPU specify 1024 Must be in multiples of 128, with the same multiplier as memory from the base
     */
    'cpu': number;
    /**
     * Memory in 128 MB increments, values are integer always in MB Must be in multiples of 128, with the same multiplier as CPU from the base
     */
    'memory': number;
}
/**
 * Type of function, worker types are not exposed to ingress routes
 */
export declare const FunctionType: {
    readonly http: "http";
    readonly worker: "worker";
};
export type FunctionType = typeof FunctionType[keyof typeof FunctionType];
/**
 * Host response
 */
export interface Host {
    /**
     * Host id
     */
    'id': string;
    /**
     * Hostname, this can be the root of a domain or a subdomain
     */
    'host': string;
    /**
     * The secret reference to the certificate
     */
    'certificate'?: string;
    /**
     * Project ID this is attached to
     */
    'project_id': string;
    /**
     * If the host is read only and cannot be removed, primarily used for *.qrnl.app domains
     */
    'read_only': boolean;
    /**
     * If the host is disabled, then this host won\'t be accessible and so the deployments will not be routable
     */
    'disabled': boolean;
    /**
     * TXT record of host to verify ownership - if this record is removed, it may become unverified as this is checked periodically to continually verify ownership
     */
    'txt_verification': string;
    /**
     * UTC datetime when the host was verified (ISO 8601 date format).
     */
    'verified_at'?: string;
    'date': ModelDate;
    'verification_status': HostVerificationStatus;
}
/**
 * Host body
 */
export interface HostBody {
    /**
     * Hostname, this can be the root of a domain or a subdomain
     */
    'host': string;
    /**
     * The secret reference to the certificate
     */
    'certificate': string;
    /**
     * If the host is disabled, then this host won\'t be accessible and so the deployments will not be routable
     */
    'disabled': boolean;
}
/**
 * Host body update
 */
export interface HostBodyPatch {
    /**
     * The secret reference to the certificate
     */
    'certificate'?: string;
    /**
     * If the host is disabled, then this host won\'t be accessible and so the deployments will not be routable
     */
    'disabled'?: boolean;
}
/**
 * Host verification status
 */
export declare const HostVerificationStatus: {
    readonly pending: "pending";
    readonly already_verified: "already_verified";
    readonly completed: "completed";
    readonly failed: "failed";
};
export type HostVerificationStatus = typeof HostVerificationStatus[keyof typeof HostVerificationStatus];
/**
 * List of auth tokens
 */
export interface ListAuthTokens {
    'meta': PaginationMeta;
    'data': Array<AuthTokenMeta>;
}
/**
 * List of functions
 */
export interface ListFunction {
    'meta': PaginationMeta;
    'data': Array<Function>;
}
/**
 * List of projects hosts
 */
export interface ListHosts {
    'meta': PaginationMeta;
    'data': Array<Host>;
}
/**
 * List of log
 */
export interface ListLogResponse {
    'meta': PaginationMeta;
    'data': Array<Log>;
}
/**
 * List organisations schema
 */
export interface ListOrganisationResponse {
    'meta': PaginationMeta;
    'data': Array<OrganisationResponse>;
}
/**
 * List of projects
 */
export interface ListProjectResponse {
    'meta': PaginationMeta;
    'data': Array<ProjectResponse>;
}
/**
 * List of providers
 */
export interface ListProviderResponse {
    'meta': PaginationMeta;
    'data': Array<Provider>;
}
/**
 * List of secrets
 */
export interface ListSecretResponse {
    'meta': PaginationMeta;
    'data': Array<SecretMetaResponse>;
}
/**
 * Location of allowed clusters
 */
export interface Location {
    /**
     * UUID of provider to deploy into
     */
    'provider_id': string;
    /**
     * Deployment continent
     */
    'continent'?: string;
    /**
     * Deployment country
     */
    'country'?: string;
    /**
     * Deployment city
     */
    'city'?: string;
}
/**
 * List of logs
 */
export interface Log {
    /**
     * Container ID the log line is for
     */
    'container'?: string;
    /**
     * Function ID the log line is for
     */
    'function'?: string;
    /**
     * Project ID the log line is for
     */
    'project'?: string;
    /**
     * Organisation ID the log line is for
     */
    'organisation'?: string;
    /**
     * Group ID the log line is for
     */
    'group'?: string;
    'log'?: LogLog;
}
/**
 * Log item
 */
export interface LogLog {
    /**
     * Which log stream
     */
    'stream'?: LogLogStreamEnum;
    /**
     * If this was an event on the function or a log line
     */
    'kind'?: LogLogKindEnum;
    /**
     * An array of labels
     */
    'labels'?: Array<string>;
    /**
     * Log line type
     */
    'type'?: LogLogTypeEnum;
    /**
     * Log line
     */
    'line'?: string;
    /**
     * The date/time that this log was generated
     */
    'timestamp'?: string;
}
export declare const LogLogStreamEnum: {
    readonly stdout: "stdout";
    readonly stderr: "stderr";
};
export type LogLogStreamEnum = typeof LogLogStreamEnum[keyof typeof LogLogStreamEnum];
export declare const LogLogKindEnum: {
    readonly event: "event";
    readonly log: "log";
};
export type LogLogKindEnum = typeof LogLogKindEnum[keyof typeof LogLogKindEnum];
export declare const LogLogTypeEnum: {
    readonly info: "info";
    readonly error: "error";
};
export type LogLogTypeEnum = typeof LogLogTypeEnum[keyof typeof LogLogTypeEnum];
export interface LogsListFTimestampsParameter {
    /**
     * Restrict to after this timestamp
     */
    'after'?: string;
    /**
     * Resitrct to before this timestamp
     */
    'before'?: string;
}
/**
 * Metric http aggregation
 */
export interface MetricHttpAggregation {
    'http_codes'?: MetricHttpAggregationHttpCodes;
}
/**
 * HTTP status code aggregation
 */
export interface MetricHttpAggregationHttpCodes {
    /**
     * Array of unique http status codes
     */
    'buckets'?: Array<MetricHttpAggregationHttpCodesBucketsInner>;
    /**
     * Upper bound of error in document count
     */
    'doc_count_error_upper_bound'?: number;
    /**
     * Sum of other document counts
     */
    'sum_other_doc_count'?: number;
}
/**
 * HTTP status code bucket
 */
export interface MetricHttpAggregationHttpCodesBucketsInner {
    /**
     * Number of documents in the bucket
     */
    'doc_count'?: number;
    'histogram'?: MetricHttpAggregationHttpCodesBucketsInnerHistogram;
    /**
     * HTTP status code, typical values will be;  - http-2xx - http-3xx - http-4xx - http-5xx  > Note: the \'xx\' is intentional and literal, all status codes within that range will be grouped
     */
    'key'?: string;
}
/**
 * Histogram of http status code usage
 */
export interface MetricHttpAggregationHttpCodesBucketsInnerHistogram {
    /**
     * Array of resource usage by interval  > Note: A metric will have either a `counter` or `gauge` value
     */
    'buckets'?: Array<MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInner>;
}
/**
 * Metric resource aggregation
 */
export interface MetricResourceAggregation {
    'resources'?: MetricResourceAggregationResources;
}
/**
 * Resource(s) aggregation
 */
export interface MetricResourceAggregationResources {
    /**
     * Array of unqiue resources
     */
    'buckets'?: Array<MetricResourceAggregationResourcesBucketsInner>;
    /**
     * Upper bound of error in document count
     */
    'doc_count_error_upper_bound'?: number;
    /**
     * Sum of other document counts
     */
    'sum_other_doc_count'?: number;
}
/**
 * Histogram bucket
 */
export interface MetricResourceAggregationResourcesBucketsInner {
    /**
     * Number of documents in the bucket
     */
    'doc_count'?: number;
    'histogram'?: MetricResourceAggregationResourcesBucketsInnerHistogram;
    /**
     * Metric key
     */
    'key'?: string;
}
/**
 * Histogram of resource usage
 */
export interface MetricResourceAggregationResourcesBucketsInnerHistogram {
    /**
     * Array of resource usage by interval  > Note: A metric will have either a `counter` or `gauge` value
     */
    'buckets'?: Array<MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInner>;
}
export interface MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInner {
    /**
     * Number of documents in the bucket
     */
    'doc_count'?: number;
    'counter'?: MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInnerCounter;
    'gauge'?: MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInnerGauge;
    /**
     * Histogram key (typically unix timestamp)
     */
    'key'?: number;
    /**
     * Histogram key as string/date-time
     */
    'key_as_string'?: string;
}
/**
 * Counter (monotonically incrementing)
 */
export interface MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInnerCounter {
    /**
     * Average counter value
     */
    'avg'?: number | null;
    /**
     * Number of counter values
     */
    'count'?: number | null;
    /**
     * Maximum counter value
     */
    'max'?: number | null;
    /**
     * Minimum counter value
     */
    'min'?: number | null;
    /**
     * Sum of counter values
     */
    'sum'?: number | null;
}
/**
 * Gauge (value at a point in time)
 */
export interface MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInnerGauge {
    /**
     * Average gauge value
     */
    'avg'?: number | null;
    /**
     * Number of gauge values
     */
    'count'?: number | null;
    /**
     * Maximum gauge value
     */
    'max'?: number | null;
    /**
     * Minimum gauge value
     */
    'min'?: number | null;
    /**
     * Sum of gauge values
     */
    'sum'?: number;
}
/**
 * @type MetricsAggregationsList200Response
 */
export type MetricsAggregationsList200Response = MetricHttpAggregation | MetricResourceAggregation;
/**
 * Object date information
 */
export interface ModelDate {
    /**
     * UTC creation datetime (ISO 8601 date format)
     */
    'created_at': string;
    /**
     * UTC update datetime (ISO 8601 date format)
     */
    'updated_at': string;
}
/**
 * Resource not found
 */
export interface NotFoundResponse {
    'message': string;
}
/**
 * Organisation body
 */
export interface OrganisationBody {
    /**
     * Organisation name
     */
    'name': string;
}
/**
 * Organisation response
 */
export interface OrganisationResponse {
    /**
     * Organisation id
     */
    'id': string;
    /**
     * User id
     */
    'user_id': string;
    /**
     * Organisation name
     */
    'name': string;
    'date': ModelDate;
}
export interface OrganisationsListPageParameter {
    /**
     * Offset
     */
    'before'?: number;
    /**
     * Offset
     */
    'after'?: number;
    /**
     * Limit
     */
    'size'?: number;
}
/**
 * Links object for pagination use
 */
export interface PaginationLinks {
    'prev': string;
    'next': string;
}
/**
 * Meta object for pagination use
 */
export interface PaginationMeta {
    'results': number;
    'start': number;
    'end': number;
    'pages': number;
    'links': PaginationLinks;
}
/**
 * Project body
 */
export interface ProjectBody {
    /**
     * Organisation id
     */
    'org_id': string;
    /**
     * Project name
     */
    'name': string;
}
/**
 * Project patch fields
 */
export interface ProjectBodyPatch {
    /**
     * Organisation id
     */
    'org_id'?: string;
    /**
     * Project name
     */
    'name'?: string;
}
/**
 * Project response
 */
export interface ProjectResponse {
    /**
     * Project id
     */
    'id': string;
    /**
     * Organisation id
     */
    'org_id': string;
    /**
     * Project name
     */
    'name': string;
    'date': ModelDate;
}
/**
 * List of providers
 */
export interface Provider {
    'id': string;
    /**
     * Name of provider
     */
    'name': string;
    'locations': ProviderLocations;
}
/**
 * Locations at varying levels this provider operates within
 */
export interface ProviderLocations {
    'continents': Array<string>;
    'countries': Array<string>;
    'cities': Array<string>;
}
/**
 * Quota usage
 */
export interface Quota {
    /**
     * Quota name
     */
    'name': string;
    /**
     * Quota description
     */
    'description': string;
    /**
     * Quota limit
     */
    'limit': number;
    /**
     * Quota usage
     */
    'usage': number;
    /**
     * Quota type (group)
     */
    'type': string;
}
/**
 * Secret body
 */
export interface SecretBody {
    /**
     * Secret name
     */
    'name': string;
    'type': SecretCreateType;
    'payload': SecretCreatePayload;
    /**
     * Encryption entity
     */
    'encryption': string;
}
/**
 * Secret body patch fields
 */
export interface SecretBodyPatch {
    'type': SecretCreateType;
    'payload': SecretCreatePayload;
    /**
     * Encryption entity
     */
    'encryption': string;
}
/**
 * Encrypted SSL private key and plain certificate. Certificate expected in x509 pem format, key expected in pkcs8 or pkcs1 pem format. `type: certificate`
 */
export interface SecretCertificate {
    /**
     * Public certificate
     */
    'certificate': string;
    /**
     * Encrypted certificate private key
     */
    'certificate_value': string;
}
/**
 * @type SecretCreatePayload
 * Payload for secret
 */
export type SecretCreatePayload = SecretCertificate | SecretEnvironment | SecretRegistry;
/**
 * Secrets types: registry, certificate, environment
 */
export declare const SecretCreateType: {
    readonly registry: "registry";
    readonly certificate: "certificate";
    readonly environment: "environment";
};
export type SecretCreateType = typeof SecretCreateType[keyof typeof SecretCreateType];
/**
 * Encrypted ENV secret, `type: environment`
 */
export interface SecretEnvironment {
    /**
     * Encrypted environment value
     */
    'environment_value': string;
}
/**
 * Secret metadata response
 */
export interface SecretMetaResponse {
    /**
     * Secret name
     */
    'name': string;
    'type': SecretMetaType;
    'payload'?: SecretMetaResponsePayload;
    /**
     * Secret revision
     */
    'revision': number;
    'date': ModelDate;
}
/**
 * Secret metadata certificate payload
 */
export interface SecretMetaResponseCertificatePayload {
    /**
     * Public SSL certificate
     */
    'certificate': string;
}
/**
 * DEK secret, `type: dek`
 */
export interface SecretMetaResponseDek {
    /**
     * Base64 encoded DEK public key
     */
    'public': string;
}
/**
 * @type SecretMetaResponsePayload
 */
export type SecretMetaResponsePayload = SecretMetaResponseCertificatePayload | SecretMetaResponseDek | SecretMetaResponseRegistryPayload;
/**
 * Secret metadata registry payload
 */
export interface SecretMetaResponseRegistryPayload {
    /**
     * Private registry domain/location, when using the private docker hub registry sepcify `docker.io` > Without http scheme
     */
    'registry': string;
}
/**
 * Secrets types: registry, certificate, environment, dek
 */
export declare const SecretMetaType: {
    readonly registry: "registry";
    readonly certificate: "certificate";
    readonly environment: "environment";
    readonly dek: "dek";
};
export type SecretMetaType = typeof SecretMetaType[keyof typeof SecretMetaType];
/**
 * Encrypted private container registry, `type: registry`
 */
export interface SecretRegistry {
    /**
     * Private registry domain/location, when using the private docker hub registry sepcify `docker.io` > Without http scheme
     */
    'registry': string;
    /**
     * Token used for auth to the registry
     */
    'registry_value': string;
}
/**
 * Secret response
 */
export interface SecretResponse {
    /**
     * Secret name
     */
    'name': string;
    'type': SecretCreateType;
    'payload'?: SecretResponsePayload;
    /**
     * Secret revision
     */
    'revision': number;
    'date': ModelDate;
}
/**
 * @type SecretResponsePayload
 */
export type SecretResponsePayload = SecretMetaResponseCertificatePayload | SecretMetaResponseRegistryPayload;
/**
 * Unauthorised
 */
export interface UnauthorisedResponse {
    'message': string;
}
/**
 * FunctionsApi - axios parameter creator
 */
export declare const FunctionsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new function
     * @summary Create function
     * @param {FunctionBody} FunctionBody Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsCreate: (FunctionBody: FunctionBody, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete a function (and all revisions)
     * @summary Delete function
     * @param {string} function_id Function ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsDelete: (function_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific function (latest revision)
     * @summary Get function (latest revision)
     * @param {string} function_id Function ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsGet: (function_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific revision of a function
     * @summary Get a specific revision of a function
     * @param {string} function_id Function ID reference
     * @param {string} function_revision_id Function revision ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsRevisionsGet: (function_id: string, function_revision_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List all revisions for a function
     * @summary List all revisions for a function
     * @param {string} function_id Function ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsRevisionsList: (function_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update a function (creates a new revision)
     * @summary Update function
     * @param {string} function_id Function ID reference
     * @param {Function} Function Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsUpdate: (function_id: string, Function: Function, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List all functions
     * @summary List all functions within a project
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsFunctionsList: (project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FunctionsApi - functional programming interface
 */
export declare const FunctionsApiFp: (configuration?: Configuration) => {
    /**
     * Create a new function
     * @summary Create function
     * @param {FunctionBody} FunctionBody Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsCreate(FunctionBody: FunctionBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Function>>;
    /**
     * Delete a function (and all revisions)
     * @summary Delete function
     * @param {string} function_id Function ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsDelete(function_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>>;
    /**
     * Get a specific function (latest revision)
     * @summary Get function (latest revision)
     * @param {string} function_id Function ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsGet(function_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Function>>;
    /**
     * Get a specific revision of a function
     * @summary Get a specific revision of a function
     * @param {string} function_id Function ID reference
     * @param {string} function_revision_id Function revision ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsRevisionsGet(function_id: string, function_revision_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Function>>;
    /**
     * List all revisions for a function
     * @summary List all revisions for a function
     * @param {string} function_id Function ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsRevisionsList(function_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFunction>>;
    /**
     * Update a function (creates a new revision)
     * @summary Update function
     * @param {string} function_id Function ID reference
     * @param {Function} Function Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsUpdate(function_id: string, Function: Function, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Function>>;
    /**
     * List all functions
     * @summary List all functions within a project
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsFunctionsList(project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFunction>>;
};
/**
 * FunctionsApi - factory interface
 */
export declare const FunctionsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new function
     * @summary Create function
     * @param {FunctionBody} FunctionBody Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsCreate(FunctionBody: FunctionBody, options?: RawAxiosRequestConfig): AxiosPromise<Function>;
    /**
     * Delete a function (and all revisions)
     * @summary Delete function
     * @param {string} function_id Function ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsDelete(function_id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse>;
    /**
     * Get a specific function (latest revision)
     * @summary Get function (latest revision)
     * @param {string} function_id Function ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsGet(function_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Function>;
    /**
     * Get a specific revision of a function
     * @summary Get a specific revision of a function
     * @param {string} function_id Function ID reference
     * @param {string} function_revision_id Function revision ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsRevisionsGet(function_id: string, function_revision_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Function>;
    /**
     * List all revisions for a function
     * @summary List all revisions for a function
     * @param {string} function_id Function ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsRevisionsList(function_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): AxiosPromise<ListFunction>;
    /**
     * Update a function (creates a new revision)
     * @summary Update function
     * @param {string} function_id Function ID reference
     * @param {Function} Function Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsUpdate(function_id: string, Function: Function, options?: RawAxiosRequestConfig): AxiosPromise<Function>;
    /**
     * List all functions
     * @summary List all functions within a project
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsFunctionsList(project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): AxiosPromise<ListFunction>;
};
/**
 * FunctionsApi - object-oriented interface
 */
export declare class FunctionsApi extends BaseAPI {
    /**
     * Create a new function
     * @summary Create function
     * @param {FunctionBody} FunctionBody Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsCreate(FunctionBody: FunctionBody, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Function, any>>;
    /**
     * Delete a function (and all revisions)
     * @summary Delete function
     * @param {string} function_id Function ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsDelete(function_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<DeletedResponse, any>>;
    /**
     * Get a specific function (latest revision)
     * @summary Get function (latest revision)
     * @param {string} function_id Function ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsGet(function_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Function, any>>;
    /**
     * Get a specific revision of a function
     * @summary Get a specific revision of a function
     * @param {string} function_id Function ID reference
     * @param {string} function_revision_id Function revision ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsRevisionsGet(function_id: string, function_revision_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Function, any>>;
    /**
     * List all revisions for a function
     * @summary List all revisions for a function
     * @param {string} function_id Function ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsRevisionsList(function_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListFunction, any>>;
    /**
     * Update a function (creates a new revision)
     * @summary Update function
     * @param {string} function_id Function ID reference
     * @param {Function} Function Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionsUpdate(function_id: string, Function: Function, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Function, any>>;
    /**
     * List all functions
     * @summary List all functions within a project
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsFunctionsList(project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListFunction, any>>;
}
/**
 * HostsApi - axios parameter creator
 */
export declare const HostsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Assign a host/domain to a project - hosts are globally unique and require verification, so a host cannot be assigned to multiple projects.  A host can be a valid domain, either a root domain or a subdomain.
     * @summary Create host for project
     * @param {string} project_id Project ID reference
     * @param {HostBody} HostBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsCreate: (project_id: string, HostBody: HostBody, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsDelete: (project_id: string, hostname: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsGet: (project_id: string, hostname: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary List hosts for project
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsList: (project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {HostBodyPatch} HostBodyPatch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsUpdate: (project_id: string, hostname: string, HostBodyPatch: HostBodyPatch, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Schedule host verification task
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsVerifyCreate: (project_id: string, hostname: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * HostsApi - functional programming interface
 */
export declare const HostsApiFp: (configuration?: Configuration) => {
    /**
     * Assign a host/domain to a project - hosts are globally unique and require verification, so a host cannot be assigned to multiple projects.  A host can be a valid domain, either a root domain or a subdomain.
     * @summary Create host for project
     * @param {string} project_id Project ID reference
     * @param {HostBody} HostBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsCreate(project_id: string, HostBody: HostBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>>;
    /**
     *
     * @summary Delete specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsDelete(project_id: string, hostname: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>>;
    /**
     *
     * @summary Get specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsGet(project_id: string, hostname: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>>;
    /**
     *
     * @summary List hosts for project
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsList(project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListHosts>>;
    /**
     *
     * @summary Update specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {HostBodyPatch} HostBodyPatch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsUpdate(project_id: string, hostname: string, HostBodyPatch: HostBodyPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>>;
    /**
     *
     * @summary Schedule host verification task
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsVerifyCreate(project_id: string, hostname: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>>;
};
/**
 * HostsApi - factory interface
 */
export declare const HostsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Assign a host/domain to a project - hosts are globally unique and require verification, so a host cannot be assigned to multiple projects.  A host can be a valid domain, either a root domain or a subdomain.
     * @summary Create host for project
     * @param {string} project_id Project ID reference
     * @param {HostBody} HostBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsCreate(project_id: string, HostBody: HostBody, options?: RawAxiosRequestConfig): AxiosPromise<Host>;
    /**
     *
     * @summary Delete specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsDelete(project_id: string, hostname: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse>;
    /**
     *
     * @summary Get specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsGet(project_id: string, hostname: string, options?: RawAxiosRequestConfig): AxiosPromise<Host>;
    /**
     *
     * @summary List hosts for project
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsList(project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): AxiosPromise<ListHosts>;
    /**
     *
     * @summary Update specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {HostBodyPatch} HostBodyPatch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsUpdate(project_id: string, hostname: string, HostBodyPatch: HostBodyPatch, options?: RawAxiosRequestConfig): AxiosPromise<Host>;
    /**
     *
     * @summary Schedule host verification task
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsVerifyCreate(project_id: string, hostname: string, options?: RawAxiosRequestConfig): AxiosPromise<Host>;
};
/**
 * HostsApi - object-oriented interface
 */
export declare class HostsApi extends BaseAPI {
    /**
     * Assign a host/domain to a project - hosts are globally unique and require verification, so a host cannot be assigned to multiple projects.  A host can be a valid domain, either a root domain or a subdomain.
     * @summary Create host for project
     * @param {string} project_id Project ID reference
     * @param {HostBody} HostBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsCreate(project_id: string, HostBody: HostBody, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Host, any>>;
    /**
     *
     * @summary Delete specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsDelete(project_id: string, hostname: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<DeletedResponse, any>>;
    /**
     *
     * @summary Get specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsGet(project_id: string, hostname: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Host, any>>;
    /**
     *
     * @summary List hosts for project
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsList(project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListHosts, any>>;
    /**
     *
     * @summary Update specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {HostBodyPatch} HostBodyPatch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsUpdate(project_id: string, hostname: string, HostBodyPatch: HostBodyPatch, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Host, any>>;
    /**
     *
     * @summary Schedule host verification task
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsHostsVerifyCreate(project_id: string, hostname: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Host, any>>;
}
/**
 * LogsApi - axios parameter creator
 */
export declare const LogsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve logs for a specific project or function. Use the query parameter to search logs.  > Note: Logs are always returned in a descending order based on the timestamp. > Note: A max size of 500 logs is returned per request (when using page[size]).
     * @summary Get logs
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_project] Project uuid reference
     * @param {string} [f_function] Function uuid reference
     * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
     * @param {string} [f_query] Text query string
     * @param {LogsListFLogTypeEnum} [f_log_type] Type of log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsList: (page?: OrganisationsListPageParameter, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_query?: string, f_log_type?: LogsListFLogTypeEnum, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * LogsApi - functional programming interface
 */
export declare const LogsApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve logs for a specific project or function. Use the query parameter to search logs.  > Note: Logs are always returned in a descending order based on the timestamp. > Note: A max size of 500 logs is returned per request (when using page[size]).
     * @summary Get logs
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_project] Project uuid reference
     * @param {string} [f_function] Function uuid reference
     * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
     * @param {string} [f_query] Text query string
     * @param {LogsListFLogTypeEnum} [f_log_type] Type of log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsList(page?: OrganisationsListPageParameter, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_query?: string, f_log_type?: LogsListFLogTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListLogResponse>>;
};
/**
 * LogsApi - factory interface
 */
export declare const LogsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieve logs for a specific project or function. Use the query parameter to search logs.  > Note: Logs are always returned in a descending order based on the timestamp. > Note: A max size of 500 logs is returned per request (when using page[size]).
     * @summary Get logs
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_project] Project uuid reference
     * @param {string} [f_function] Function uuid reference
     * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
     * @param {string} [f_query] Text query string
     * @param {LogsListFLogTypeEnum} [f_log_type] Type of log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsList(page?: OrganisationsListPageParameter, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_query?: string, f_log_type?: LogsListFLogTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListLogResponse>;
};
/**
 * LogsApi - object-oriented interface
 */
export declare class LogsApi extends BaseAPI {
    /**
     * Retrieve logs for a specific project or function. Use the query parameter to search logs.  > Note: Logs are always returned in a descending order based on the timestamp. > Note: A max size of 500 logs is returned per request (when using page[size]).
     * @summary Get logs
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_project] Project uuid reference
     * @param {string} [f_function] Function uuid reference
     * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
     * @param {string} [f_query] Text query string
     * @param {LogsListFLogTypeEnum} [f_log_type] Type of log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsList(page?: OrganisationsListPageParameter, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_query?: string, f_log_type?: LogsListFLogTypeEnum, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListLogResponse, any>>;
}
export declare const LogsListFLogTypeEnum: {
    readonly info: "info";
    readonly error: "error";
};
export type LogsListFLogTypeEnum = typeof LogsListFLogTypeEnum[keyof typeof LogsListFLogTypeEnum];
/**
 * MetricsApi - axios parameter creator
 */
export declare const MetricsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve metrics for a specific project or function. Use the query parameter to request a metrics report.  > Note: Metrics are always returned in a descending order based on the timestamp.
     * @summary Get metrics
     * @param {MetricsAggregationsListMetricAggregationTypeEnum} metric_aggregation_type Metric aggregation type, types can be used with either a project or a function filter.  - httprequests: Aggregated HTTP requests - resourcestats: Aggregated resource stats (such as CPU, Memory and Network)  &gt; Note: aggregations cannot return more than 300 data points
     * @param {string} [f_project] Project uuid reference
     * @param {string} [f_function] Function uuid reference
     * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
     * @param {number} [f_histogram_interval] Histogram interval
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metricsAggregationsList: (metric_aggregation_type: MetricsAggregationsListMetricAggregationTypeEnum, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_histogram_interval?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MetricsApi - functional programming interface
 */
export declare const MetricsApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve metrics for a specific project or function. Use the query parameter to request a metrics report.  > Note: Metrics are always returned in a descending order based on the timestamp.
     * @summary Get metrics
     * @param {MetricsAggregationsListMetricAggregationTypeEnum} metric_aggregation_type Metric aggregation type, types can be used with either a project or a function filter.  - httprequests: Aggregated HTTP requests - resourcestats: Aggregated resource stats (such as CPU, Memory and Network)  &gt; Note: aggregations cannot return more than 300 data points
     * @param {string} [f_project] Project uuid reference
     * @param {string} [f_function] Function uuid reference
     * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
     * @param {number} [f_histogram_interval] Histogram interval
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metricsAggregationsList(metric_aggregation_type: MetricsAggregationsListMetricAggregationTypeEnum, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_histogram_interval?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsAggregationsList200Response>>;
};
/**
 * MetricsApi - factory interface
 */
export declare const MetricsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieve metrics for a specific project or function. Use the query parameter to request a metrics report.  > Note: Metrics are always returned in a descending order based on the timestamp.
     * @summary Get metrics
     * @param {MetricsAggregationsListMetricAggregationTypeEnum} metric_aggregation_type Metric aggregation type, types can be used with either a project or a function filter.  - httprequests: Aggregated HTTP requests - resourcestats: Aggregated resource stats (such as CPU, Memory and Network)  &gt; Note: aggregations cannot return more than 300 data points
     * @param {string} [f_project] Project uuid reference
     * @param {string} [f_function] Function uuid reference
     * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
     * @param {number} [f_histogram_interval] Histogram interval
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metricsAggregationsList(metric_aggregation_type: MetricsAggregationsListMetricAggregationTypeEnum, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_histogram_interval?: number, options?: RawAxiosRequestConfig): AxiosPromise<MetricsAggregationsList200Response>;
};
/**
 * MetricsApi - object-oriented interface
 */
export declare class MetricsApi extends BaseAPI {
    /**
     * Retrieve metrics for a specific project or function. Use the query parameter to request a metrics report.  > Note: Metrics are always returned in a descending order based on the timestamp.
     * @summary Get metrics
     * @param {MetricsAggregationsListMetricAggregationTypeEnum} metric_aggregation_type Metric aggregation type, types can be used with either a project or a function filter.  - httprequests: Aggregated HTTP requests - resourcestats: Aggregated resource stats (such as CPU, Memory and Network)  &gt; Note: aggregations cannot return more than 300 data points
     * @param {string} [f_project] Project uuid reference
     * @param {string} [f_function] Function uuid reference
     * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
     * @param {number} [f_histogram_interval] Histogram interval
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metricsAggregationsList(metric_aggregation_type: MetricsAggregationsListMetricAggregationTypeEnum, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_histogram_interval?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<MetricsAggregationsList200Response, any>>;
}
export declare const MetricsAggregationsListMetricAggregationTypeEnum: {
    readonly httprequests: "httprequests";
    readonly resourcestats: "resourcestats";
};
export type MetricsAggregationsListMetricAggregationTypeEnum = typeof MetricsAggregationsListMetricAggregationTypeEnum[keyof typeof MetricsAggregationsListMetricAggregationTypeEnum];
/**
 * OrganisationsApi - axios parameter creator
 */
export declare const OrganisationsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create an organisation
     * @summary Create organisations
     * @param {OrganisationBody} [OrganisationBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsCreate: (OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete organisation, this will also delete all the resources within the organisation
     * @summary Delete an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsDelete: (organisation_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a single organisation
     * @summary Get an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsGet: (organisation_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List organisations
     * @summary List organisations
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsList: (page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific quota for an organisation
     * @summary Get specific organisation quota
     * @param {string} organisation_id Organisation ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasGet: (organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the quotas for an organisation
     * @summary List organisation quotas
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasList: (organisation_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update an organisation
     * @summary Update an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {OrganisationBody} [OrganisationBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsUpdate: (organisation_id: string, OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * OrganisationsApi - functional programming interface
 */
export declare const OrganisationsApiFp: (configuration?: Configuration) => {
    /**
     * Create an organisation
     * @summary Create organisations
     * @param {OrganisationBody} [OrganisationBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsCreate(OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponse>>;
    /**
     * Delete organisation, this will also delete all the resources within the organisation
     * @summary Delete an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsDelete(organisation_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>>;
    /**
     * Get a single organisation
     * @summary Get an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsGet(organisation_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponse>>;
    /**
     * List organisations
     * @summary List organisations
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsList(page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrganisationResponse>>;
    /**
     * Get a specific quota for an organisation
     * @summary Get specific organisation quota
     * @param {string} organisation_id Organisation ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasGet(organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>>;
    /**
     * Get the quotas for an organisation
     * @summary List organisation quotas
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasList(organisation_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>>;
    /**
     * Update an organisation
     * @summary Update an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {OrganisationBody} [OrganisationBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsUpdate(organisation_id: string, OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponse>>;
};
/**
 * OrganisationsApi - factory interface
 */
export declare const OrganisationsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create an organisation
     * @summary Create organisations
     * @param {OrganisationBody} [OrganisationBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsCreate(OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig): AxiosPromise<OrganisationResponse>;
    /**
     * Delete organisation, this will also delete all the resources within the organisation
     * @summary Delete an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsDelete(organisation_id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse>;
    /**
     * Get a single organisation
     * @summary Get an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsGet(organisation_id: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganisationResponse>;
    /**
     * List organisations
     * @summary List organisations
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsList(page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListOrganisationResponse>;
    /**
     * Get a specific quota for an organisation
     * @summary Get specific organisation quota
     * @param {string} organisation_id Organisation ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasGet(organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>>;
    /**
     * Get the quotas for an organisation
     * @summary List organisation quotas
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasList(organisation_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>>;
    /**
     * Update an organisation
     * @summary Update an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {OrganisationBody} [OrganisationBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsUpdate(organisation_id: string, OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig): AxiosPromise<OrganisationResponse>;
};
/**
 * OrganisationsApi - object-oriented interface
 */
export declare class OrganisationsApi extends BaseAPI {
    /**
     * Create an organisation
     * @summary Create organisations
     * @param {OrganisationBody} [OrganisationBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsCreate(OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<OrganisationResponse, any>>;
    /**
     * Delete organisation, this will also delete all the resources within the organisation
     * @summary Delete an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsDelete(organisation_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<DeletedResponse, any>>;
    /**
     * Get a single organisation
     * @summary Get an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsGet(organisation_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<OrganisationResponse, any>>;
    /**
     * List organisations
     * @summary List organisations
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsList(page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListOrganisationResponse, any>>;
    /**
     * Get a specific quota for an organisation
     * @summary Get specific organisation quota
     * @param {string} organisation_id Organisation ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasGet(organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Quota[], any>>;
    /**
     * Get the quotas for an organisation
     * @summary List organisation quotas
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasList(organisation_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Quota[], any>>;
    /**
     * Update an organisation
     * @summary Update an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {OrganisationBody} [OrganisationBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsUpdate(organisation_id: string, OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<OrganisationResponse, any>>;
}
/**
 * ProjectsApi - axios parameter creator
 */
export declare const ProjectsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get all the projects linked to a specific organisation
     * @summary Get all projects within an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsProjectsList: (organisation_id: string, page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new project
     * @summary Create project
     * @param {ProjectBody} [ProjectBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsCreate: (ProjectBody?: ProjectBody, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete project, this will also delete all the resources within the project
     * @summary Delete project
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsDelete: (project_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific project
     * @summary Get project
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsGet: (project_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get all projects for this user, paginated
     * @summary List projects
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsList: (page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific quota for a project
     * @summary Get specific project quota
     * @param {string} project_id Project ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasGet: (project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the quotas for a project
     * @summary List project quotas
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasList: (project_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update project
     * @summary Update project
     * @param {string} project_id Project ID reference
     * @param {ProjectBodyPatch} [ProjectBodyPatch] Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsUpdate: (project_id: string, ProjectBodyPatch?: ProjectBodyPatch, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectsApi - functional programming interface
 */
export declare const ProjectsApiFp: (configuration?: Configuration) => {
    /**
     * Get all the projects linked to a specific organisation
     * @summary Get all projects within an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsProjectsList(organisation_id: string, page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjectResponse>>;
    /**
     * Create a new project
     * @summary Create project
     * @param {ProjectBody} [ProjectBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsCreate(ProjectBody?: ProjectBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>>;
    /**
     * Delete project, this will also delete all the resources within the project
     * @summary Delete project
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsDelete(project_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>>;
    /**
     * Get a specific project
     * @summary Get project
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsGet(project_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>>;
    /**
     * Get all projects for this user, paginated
     * @summary List projects
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsList(page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjectResponse>>;
    /**
     * Get a specific quota for a project
     * @summary Get specific project quota
     * @param {string} project_id Project ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasGet(project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>>;
    /**
     * Get the quotas for a project
     * @summary List project quotas
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasList(project_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>>;
    /**
     * Update project
     * @summary Update project
     * @param {string} project_id Project ID reference
     * @param {ProjectBodyPatch} [ProjectBodyPatch] Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsUpdate(project_id: string, ProjectBodyPatch?: ProjectBodyPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>>;
};
/**
 * ProjectsApi - factory interface
 */
export declare const ProjectsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get all the projects linked to a specific organisation
     * @summary Get all projects within an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsProjectsList(organisation_id: string, page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListProjectResponse>;
    /**
     * Create a new project
     * @summary Create project
     * @param {ProjectBody} [ProjectBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsCreate(ProjectBody?: ProjectBody, options?: RawAxiosRequestConfig): AxiosPromise<ProjectResponse>;
    /**
     * Delete project, this will also delete all the resources within the project
     * @summary Delete project
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsDelete(project_id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse>;
    /**
     * Get a specific project
     * @summary Get project
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsGet(project_id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectResponse>;
    /**
     * Get all projects for this user, paginated
     * @summary List projects
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsList(page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListProjectResponse>;
    /**
     * Get a specific quota for a project
     * @summary Get specific project quota
     * @param {string} project_id Project ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasGet(project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>>;
    /**
     * Get the quotas for a project
     * @summary List project quotas
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasList(project_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>>;
    /**
     * Update project
     * @summary Update project
     * @param {string} project_id Project ID reference
     * @param {ProjectBodyPatch} [ProjectBodyPatch] Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsUpdate(project_id: string, ProjectBodyPatch?: ProjectBodyPatch, options?: RawAxiosRequestConfig): AxiosPromise<ProjectResponse>;
};
/**
 * ProjectsApi - object-oriented interface
 */
export declare class ProjectsApi extends BaseAPI {
    /**
     * Get all the projects linked to a specific organisation
     * @summary Get all projects within an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsProjectsList(organisation_id: string, page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListProjectResponse, any>>;
    /**
     * Create a new project
     * @summary Create project
     * @param {ProjectBody} [ProjectBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsCreate(ProjectBody?: ProjectBody, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectResponse, any>>;
    /**
     * Delete project, this will also delete all the resources within the project
     * @summary Delete project
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsDelete(project_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<DeletedResponse, any>>;
    /**
     * Get a specific project
     * @summary Get project
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsGet(project_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectResponse, any>>;
    /**
     * Get all projects for this user, paginated
     * @summary List projects
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsList(page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListProjectResponse, any>>;
    /**
     * Get a specific quota for a project
     * @summary Get specific project quota
     * @param {string} project_id Project ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasGet(project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Quota[], any>>;
    /**
     * Get the quotas for a project
     * @summary List project quotas
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasList(project_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Quota[], any>>;
    /**
     * Update project
     * @summary Update project
     * @param {string} project_id Project ID reference
     * @param {ProjectBodyPatch} [ProjectBodyPatch] Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsUpdate(project_id: string, ProjectBodyPatch?: ProjectBodyPatch, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectResponse, any>>;
}
/**
 * ProvidersApi - axios parameter creator
 */
export declare const ProvidersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve a list of all providers with their respective deployed regions and cities.
     * @summary Get available providers
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    providersList: (page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProvidersApi - functional programming interface
 */
export declare const ProvidersApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve a list of all providers with their respective deployed regions and cities.
     * @summary Get available providers
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    providersList(page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProviderResponse>>;
};
/**
 * ProvidersApi - factory interface
 */
export declare const ProvidersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieve a list of all providers with their respective deployed regions and cities.
     * @summary Get available providers
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    providersList(page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): AxiosPromise<ListProviderResponse>;
};
/**
 * ProvidersApi - object-oriented interface
 */
export declare class ProvidersApi extends BaseAPI {
    /**
     * Retrieve a list of all providers with their respective deployed regions and cities.
     * @summary Get available providers
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    providersList(page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListProviderResponse, any>>;
}
/**
 * QuotasApi - axios parameter creator
 */
export declare const QuotasApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get a specific quota for an organisation
     * @summary Get specific organisation quota
     * @param {string} organisation_id Organisation ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasGet: (organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the quotas for an organisation
     * @summary List organisation quotas
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasList: (organisation_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific quota for a project
     * @summary Get specific project quota
     * @param {string} project_id Project ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasGet: (project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the quotas for a project
     * @summary List project quotas
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasList: (project_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific quota for a user
     * @summary Get specific user quota
     * @param {string} user_id User ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasGet: (user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the quotas for a user
     * @summary List user quotas
     * @param {string} user_id User ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasList: (user_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * QuotasApi - functional programming interface
 */
export declare const QuotasApiFp: (configuration?: Configuration) => {
    /**
     * Get a specific quota for an organisation
     * @summary Get specific organisation quota
     * @param {string} organisation_id Organisation ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasGet(organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>>;
    /**
     * Get the quotas for an organisation
     * @summary List organisation quotas
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasList(organisation_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>>;
    /**
     * Get a specific quota for a project
     * @summary Get specific project quota
     * @param {string} project_id Project ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasGet(project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>>;
    /**
     * Get the quotas for a project
     * @summary List project quotas
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasList(project_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>>;
    /**
     * Get a specific quota for a user
     * @summary Get specific user quota
     * @param {string} user_id User ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasGet(user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>>;
    /**
     * Get the quotas for a user
     * @summary List user quotas
     * @param {string} user_id User ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasList(user_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>>;
};
/**
 * QuotasApi - factory interface
 */
export declare const QuotasApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get a specific quota for an organisation
     * @summary Get specific organisation quota
     * @param {string} organisation_id Organisation ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasGet(organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>>;
    /**
     * Get the quotas for an organisation
     * @summary List organisation quotas
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasList(organisation_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>>;
    /**
     * Get a specific quota for a project
     * @summary Get specific project quota
     * @param {string} project_id Project ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasGet(project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>>;
    /**
     * Get the quotas for a project
     * @summary List project quotas
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasList(project_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>>;
    /**
     * Get a specific quota for a user
     * @summary Get specific user quota
     * @param {string} user_id User ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasGet(user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>>;
    /**
     * Get the quotas for a user
     * @summary List user quotas
     * @param {string} user_id User ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasList(user_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>>;
};
/**
 * QuotasApi - object-oriented interface
 */
export declare class QuotasApi extends BaseAPI {
    /**
     * Get a specific quota for an organisation
     * @summary Get specific organisation quota
     * @param {string} organisation_id Organisation ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasGet(organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Quota[], any>>;
    /**
     * Get the quotas for an organisation
     * @summary List organisation quotas
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    organisationsQuotasList(organisation_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Quota[], any>>;
    /**
     * Get a specific quota for a project
     * @summary Get specific project quota
     * @param {string} project_id Project ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasGet(project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Quota[], any>>;
    /**
     * Get the quotas for a project
     * @summary List project quotas
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsQuotasList(project_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Quota[], any>>;
    /**
     * Get a specific quota for a user
     * @summary Get specific user quota
     * @param {string} user_id User ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasGet(user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Quota[], any>>;
    /**
     * Get the quotas for a user
     * @summary List user quotas
     * @param {string} user_id User ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasList(user_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Quota[], any>>;
}
/**
 * SecretsApi - axios parameter creator
 */
export declare const SecretsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new project secret
     * @summary Create project secret
     * @param {string} project_id Project ID reference
     * @param {SecretBody} SecretBody Create/Update any field  The example generated may only be for one of the secret types, look towards the payload section of the schema for further fields, values and examples.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsCreate: (project_id: string, SecretBody: SecretBody, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete project secret, if the secret is still linked to an active/deployed function - it cannot be removed
     * @summary Delete project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsDelete: (project_id: string, secret_name: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific project
     * @summary Get project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsGet: (project_id: string, secret_name: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List project secrets of a specific type
     * @summary List project secrets of a specific type
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {SecretMetaType} [secret_type] Type of secret to filter on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsList: (project_id: string, page?: OrganisationsListPageParameter, secret_type?: SecretMetaType, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update project
     * @summary Update project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {SecretBodyPatch} SecretBodyPatch Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsUpdate: (project_id: string, secret_name: string, SecretBodyPatch: SecretBodyPatch, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * SecretsApi - functional programming interface
 */
export declare const SecretsApiFp: (configuration?: Configuration) => {
    /**
     * Create a new project secret
     * @summary Create project secret
     * @param {string} project_id Project ID reference
     * @param {SecretBody} SecretBody Create/Update any field  The example generated may only be for one of the secret types, look towards the payload section of the schema for further fields, values and examples.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsCreate(project_id: string, SecretBody: SecretBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>>;
    /**
     * Delete project secret, if the secret is still linked to an active/deployed function - it cannot be removed
     * @summary Delete project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsDelete(project_id: string, secret_name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>>;
    /**
     * Get a specific project
     * @summary Get project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsGet(project_id: string, secret_name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretMetaResponse>>;
    /**
     * List project secrets of a specific type
     * @summary List project secrets of a specific type
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {SecretMetaType} [secret_type] Type of secret to filter on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsList(project_id: string, page?: OrganisationsListPageParameter, secret_type?: SecretMetaType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSecretResponse>>;
    /**
     * Update project
     * @summary Update project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {SecretBodyPatch} SecretBodyPatch Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsUpdate(project_id: string, secret_name: string, SecretBodyPatch: SecretBodyPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>>;
};
/**
 * SecretsApi - factory interface
 */
export declare const SecretsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new project secret
     * @summary Create project secret
     * @param {string} project_id Project ID reference
     * @param {SecretBody} SecretBody Create/Update any field  The example generated may only be for one of the secret types, look towards the payload section of the schema for further fields, values and examples.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsCreate(project_id: string, SecretBody: SecretBody, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponse>;
    /**
     * Delete project secret, if the secret is still linked to an active/deployed function - it cannot be removed
     * @summary Delete project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsDelete(project_id: string, secret_name: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse>;
    /**
     * Get a specific project
     * @summary Get project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsGet(project_id: string, secret_name: string, options?: RawAxiosRequestConfig): AxiosPromise<SecretMetaResponse>;
    /**
     * List project secrets of a specific type
     * @summary List project secrets of a specific type
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {SecretMetaType} [secret_type] Type of secret to filter on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsList(project_id: string, page?: OrganisationsListPageParameter, secret_type?: SecretMetaType, options?: RawAxiosRequestConfig): AxiosPromise<ListSecretResponse>;
    /**
     * Update project
     * @summary Update project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {SecretBodyPatch} SecretBodyPatch Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsUpdate(project_id: string, secret_name: string, SecretBodyPatch: SecretBodyPatch, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponse>;
};
/**
 * SecretsApi - object-oriented interface
 */
export declare class SecretsApi extends BaseAPI {
    /**
     * Create a new project secret
     * @summary Create project secret
     * @param {string} project_id Project ID reference
     * @param {SecretBody} SecretBody Create/Update any field  The example generated may only be for one of the secret types, look towards the payload section of the schema for further fields, values and examples.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsCreate(project_id: string, SecretBody: SecretBody, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SecretResponse, any>>;
    /**
     * Delete project secret, if the secret is still linked to an active/deployed function - it cannot be removed
     * @summary Delete project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsDelete(project_id: string, secret_name: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<DeletedResponse, any>>;
    /**
     * Get a specific project
     * @summary Get project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsGet(project_id: string, secret_name: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SecretMetaResponse, any>>;
    /**
     * List project secrets of a specific type
     * @summary List project secrets of a specific type
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {SecretMetaType} [secret_type] Type of secret to filter on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsList(project_id: string, page?: OrganisationsListPageParameter, secret_type?: SecretMetaType, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListSecretResponse, any>>;
    /**
     * Update project
     * @summary Update project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {SecretBodyPatch} SecretBodyPatch Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsSecretsUpdate(project_id: string, secret_name: string, SecretBodyPatch: SecretBodyPatch, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SecretResponse, any>>;
}
/**
 * TokensApi - axios parameter creator
 */
export declare const TokensApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create new auth token for use with the CLI and TF Provider  ### Warning The `token` field is only shown once and can\'t be retrieved again without generating a new token. Securely save this once the response has been received.
     * @summary Create new auth token
     * @param {AuthTokenBody} AuthTokenBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensCreate: (AuthTokenBody: AuthTokenBody, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete token
     * @param {string} token_id Token ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensDelete: (token_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get token information
     * @param {string} token_id Token ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensGet: (token_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary List all user auth tokens
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensList: (page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update token
     * @param {string} token_id Token ID reference
     * @param {AuthTokenPatch} AuthTokenPatch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensUpdate: (token_id: string, AuthTokenPatch: AuthTokenPatch, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TokensApi - functional programming interface
 */
export declare const TokensApiFp: (configuration?: Configuration) => {
    /**
     * Create new auth token for use with the CLI and TF Provider  ### Warning The `token` field is only shown once and can\'t be retrieved again without generating a new token. Securely save this once the response has been received.
     * @summary Create new auth token
     * @param {AuthTokenBody} AuthTokenBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensCreate(AuthTokenBody: AuthTokenBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>>;
    /**
     *
     * @summary Delete token
     * @param {string} token_id Token ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensDelete(token_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>>;
    /**
     *
     * @summary Get token information
     * @param {string} token_id Token ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensGet(token_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenMeta>>;
    /**
     *
     * @summary List all user auth tokens
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensList(page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAuthTokens>>;
    /**
     *
     * @summary Update token
     * @param {string} token_id Token ID reference
     * @param {AuthTokenPatch} AuthTokenPatch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensUpdate(token_id: string, AuthTokenPatch: AuthTokenPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>>;
};
/**
 * TokensApi - factory interface
 */
export declare const TokensApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create new auth token for use with the CLI and TF Provider  ### Warning The `token` field is only shown once and can\'t be retrieved again without generating a new token. Securely save this once the response has been received.
     * @summary Create new auth token
     * @param {AuthTokenBody} AuthTokenBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensCreate(AuthTokenBody: AuthTokenBody, options?: RawAxiosRequestConfig): AxiosPromise<AuthToken>;
    /**
     *
     * @summary Delete token
     * @param {string} token_id Token ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensDelete(token_id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse>;
    /**
     *
     * @summary Get token information
     * @param {string} token_id Token ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensGet(token_id: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthTokenMeta>;
    /**
     *
     * @summary List all user auth tokens
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensList(page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): AxiosPromise<ListAuthTokens>;
    /**
     *
     * @summary Update token
     * @param {string} token_id Token ID reference
     * @param {AuthTokenPatch} AuthTokenPatch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensUpdate(token_id: string, AuthTokenPatch: AuthTokenPatch, options?: RawAxiosRequestConfig): AxiosPromise<AuthToken>;
};
/**
 * TokensApi - object-oriented interface
 */
export declare class TokensApi extends BaseAPI {
    /**
     * Create new auth token for use with the CLI and TF Provider  ### Warning The `token` field is only shown once and can\'t be retrieved again without generating a new token. Securely save this once the response has been received.
     * @summary Create new auth token
     * @param {AuthTokenBody} AuthTokenBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensCreate(AuthTokenBody: AuthTokenBody, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthToken, any>>;
    /**
     *
     * @summary Delete token
     * @param {string} token_id Token ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensDelete(token_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<DeletedResponse, any>>;
    /**
     *
     * @summary Get token information
     * @param {string} token_id Token ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensGet(token_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthTokenMeta, any>>;
    /**
     *
     * @summary List all user auth tokens
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensList(page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListAuthTokens, any>>;
    /**
     *
     * @summary Update token
     * @param {string} token_id Token ID reference
     * @param {AuthTokenPatch} AuthTokenPatch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokensUpdate(token_id: string, AuthTokenPatch: AuthTokenPatch, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthToken, any>>;
}
/**
 * UsersApi - axios parameter creator
 */
export declare const UsersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get a specific quota for a user
     * @summary Get specific user quota
     * @param {string} user_id User ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasGet: (user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the quotas for a user
     * @summary List user quotas
     * @param {string} user_id User ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasList: (user_id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UsersApi - functional programming interface
 */
export declare const UsersApiFp: (configuration?: Configuration) => {
    /**
     * Get a specific quota for a user
     * @summary Get specific user quota
     * @param {string} user_id User ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasGet(user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>>;
    /**
     * Get the quotas for a user
     * @summary List user quotas
     * @param {string} user_id User ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasList(user_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>>;
};
/**
 * UsersApi - factory interface
 */
export declare const UsersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get a specific quota for a user
     * @summary Get specific user quota
     * @param {string} user_id User ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasGet(user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>>;
    /**
     * Get the quotas for a user
     * @summary List user quotas
     * @param {string} user_id User ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasList(user_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>>;
};
/**
 * UsersApi - object-oriented interface
 */
export declare class UsersApi extends BaseAPI {
    /**
     * Get a specific quota for a user
     * @summary Get specific user quota
     * @param {string} user_id User ID reference
     * @param {string} quota_entity_quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasGet(user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Quota[], any>>;
    /**
     * Get the quotas for a user
     * @summary List user quotas
     * @param {string} user_id User ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersQuotasList(user_id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Quota[], any>>;
}
