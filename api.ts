/* tslint:disable */
/* eslint-disable */
/**
 * Chaos
 * Central Management API - publicly exposed set of APIs for cloud resources
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: help@qernal.support
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * API auth token
 */
export interface AuthToken {
    /**
     * Auth token uuid
     */
    'id': string;
    /**
     * User
     */
    'user_id': string;
    /**
     * Name of token
     */
    'name': string;
    /**
     * When the token expires
     */
    'expiry_at'?: string;
    /**
     * Combined token required for requesting an access token, this field is only returned once on creation or update (during regeneration).
     */
    'token'?: string;
    'date': ModelDate;
}
/**
 * API auth token create
 */
export interface AuthTokenBody {
    /**
     * Name of token
     */
    'name': string;
    /**
     * Token expiration duration in days. 0 - token will never expire
     */
    'expiry_duration': number;
}
/**
 * API auth token meta
 */
export interface AuthTokenMeta {
    'id': string;
    /**
     * User
     */
    'user_id': string;
    /**
     * Name of token
     */
    'name': string;
    'expiry_at'?: string;
    'date': ModelDate;
}
/**
 * API auth token patch
 */
export interface AuthTokenPatch {
    /**
     * Name of token
     */
    'name'?: string;
    /**
     * Token expiration duration in days. 0 - token will never expire
     */
    'expiry_duration'?: number;
}
/**
 * Bad request
 */
export interface BadRequestResponse {
    'message': string;
    'fields': BadRequestResponseFields;
}
export interface BadRequestResponseFields {
    'email'?: string;
}
/**
 * Billing account
 */
export interface BillingAccount {
    /**
     * Unique identifier for the billing account
     */
    'id'?: string;
    /**
     * User ID associated with the billing account
     */
    'user_id'?: string;
    /**
     * Name of the billing account
     */
    'name'?: string;
    /**
     * Current state of the billing account - new accounts are created with state \"created\" until a card is added
     */
    'state'?: BillingAccountStateEnum;
    /**
     * Current balance of the billing account
     */
    'balance'?: number;
    /**
     * Timestamp when the billing account was created
     */
    'created_at'?: string;
    /**
     * Timestamp when the billing account was last updated
     */
    'updated_at'?: string;
}

export const BillingAccountStateEnum = {
    created: 'created',
    active: 'active',
    inactive: 'inactive',
    suspended: 'suspended',
    deleted: 'deleted'
} as const;

export type BillingAccountStateEnum = typeof BillingAccountStateEnum[keyof typeof BillingAccountStateEnum];

/**
 * Billing account body
 */
export interface BillingAccountBody {
    /**
     * Name of the billing account
     */
    'name': string;
}
/**
 * Conflict Response
 */
export interface ConflictResponse {
    'message': string;
}
/**
 * Deleted Response
 */
export interface DeletedResponse {
    'message': string;
}
/**
 * Function
 */
export interface Function {
    /**
     * ID of the function
     */
    'id': string;
    /**
     * ID of the project this function belongs to
     */
    'project_id': string;
    /**
     * Function spec version
     */
    'version': FunctionVersionEnum;
    /**
     * Name of the function
     */
    'name': string;
    /**
     * Description of what the function does
     */
    'description': string;
    /**
     * Path to container image
     */
    'image': string;
    /**
     * Function revision
     */
    'revision': string;
    'type': FunctionType;
    'size': FunctionSize;
    /**
     * Port the application runs on
     */
    'port': number;
    /**
     * The public route/path to this function, only applicable to http type functions
     */
    'routes'?: Array<FunctionRoute>;
    'scaling': FunctionScaling;
    /**
     * List of deployments for this function
     */
    'deployments': Array<FunctionDeployment>;
    /**
     * List of environment variables for secrets
     */
    'secrets': Array<FunctionEnv>;
    /**
     * Tags to limit deployment
     */
    'compliance': Array<FunctionCompliance>;
}

export const FunctionVersionEnum = {
    _1_0_0: '1.0.0'
} as const;

export type FunctionVersionEnum = typeof FunctionVersionEnum[keyof typeof FunctionVersionEnum];

/**
 * Function create body
 */
export interface FunctionBody {
    /**
     * ID of the project this function belongs to
     */
    'project_id': string;
    /**
     * Function spec version
     */
    'version': FunctionBodyVersionEnum;
    /**
     * Name of the function
     */
    'name': string;
    /**
     * Description of what the function does
     */
    'description': string;
    /**
     * Path to container image
     */
    'image': string;
    'type': FunctionType;
    'size': FunctionSize;
    /**
     * Port the application runs on
     */
    'port': number;
    /**
     * The public route/path to this function, only applicable to http type functions
     */
    'routes'?: Array<FunctionRoute>;
    'scaling': FunctionScaling;
    /**
     * List of deployments for this function
     */
    'deployments': Array<FunctionDeploymentBody>;
    /**
     * List of environment variables for secrets
     */
    'secrets': Array<FunctionEnv>;
    /**
     * Tags to limit deployment
     */
    'compliance': Array<FunctionCompliance>;
}

export const FunctionBodyVersionEnum = {
    _1_0_0: '1.0.0'
} as const;

export type FunctionBodyVersionEnum = typeof FunctionBodyVersionEnum[keyof typeof FunctionBodyVersionEnum];

/**
 * Tagged requirements for compliance; soc2 = SOC2 compliant data centers ipv6 = Function can work within an ipv6 *only* cluster 
 */

export const FunctionCompliance = {
    soc2: 'soc2',
    ipv6: 'ipv6'
} as const;

export type FunctionCompliance = typeof FunctionCompliance[keyof typeof FunctionCompliance];


export interface FunctionDeployment {
    /**
     * ID of the deployment
     */
    'id'?: string;
    'location': Location;
    'replicas': FunctionReplicas;
}
export interface FunctionDeploymentBody {
    'location': Location;
    'replicas': FunctionReplicas;
}
/**
 * Environment variable for function
 */
export interface FunctionEnv {
    /**
     * Key name
     */
    'name': string;
    /**
     * Reference for the secret, it\'s split up into 4 main parts; - [1] \"projects:\" - This references which resource type the secret is within - [2] \"0a6b9ff3-6807-4820-b94b-5e1d7efcdd93\" - The project UUID the secret is within - [3] \"MY_SECRET\" - The name of the secret - [4] \"0\" - The revision of the secret to use 
     */
    'reference': string;
}
/**
 * Balancing logic
 */
export interface FunctionReplicas {
    /**
     * Minimum number of replicas to have
     */
    'min': number;
    /**
     * Maximum number of replicas to have
     */
    'max': number;
    'affinity': FunctionReplicasAffinity;
}
/**
 * Replica strategy
 */
export interface FunctionReplicasAffinity {
    /**
     * If there are > 1 replica, make sure they\'re on different clusters
     */
    'cluster': boolean;
    /**
     * If there are > 1 replica, make sure they\'re on different clouds
     */
    'cloud': boolean;
}
export interface FunctionRoute {
    /**
     * Can be a regular expression
     */
    'path': string;
    /**
     * HTTP Verb(s) for this function
     */
    'methods': Array<string>;
    /**
     * The route weight for consideration
     */
    'weight': number;
}
/**
 * Scaling logic
 */
export interface FunctionScaling {
    /**
     * CPU or Memory supported
     */
    'type': FunctionScalingTypeEnum;
    /**
     * For type to drop below before scale down
     */
    'low': number;
    /**
     * For type to go above before scale up
     */
    'high': number;
}

export const FunctionScalingTypeEnum = {
    cpu: 'cpu',
    memory: 'memory'
} as const;

export type FunctionScalingTypeEnum = typeof FunctionScalingTypeEnum[keyof typeof FunctionScalingTypeEnum];

/**
 * Size of function, required CPU and Memory
 */
export interface FunctionSize {
    /**
     * CPU in 0.1 vCPU increments, for a whole vCPU specify 1024 Must be in multiples of 128, with the same multiplier as memory from the base 
     */
    'cpu': number;
    /**
     * Memory in 128 MB increments, values are integer always in MB Must be in multiples of 128, with the same multiplier as CPU from the base 
     */
    'memory': number;
}
/**
 * Type of function, worker types are not exposed to ingress routes
 */

export const FunctionType = {
    http: 'http',
    worker: 'worker'
} as const;

export type FunctionType = typeof FunctionType[keyof typeof FunctionType];


/**
 * Host response
 */
export interface Host {
    /**
     * Host id
     */
    'id': string;
    /**
     * Hostname, this can be the root of a domain or a subdomain
     */
    'host': string;
    /**
     * The secret reference to the certificate
     */
    'certificate'?: string;
    /**
     * Project ID this is attached to
     */
    'project_id': string;
    /**
     * If the host is read only and cannot be removed, primarily used for *.qrnl.app domains
     */
    'read_only': boolean;
    /**
     * If the host is disabled, then this host won\'t be accessible and so the deployments will not be routable
     */
    'disabled': boolean;
    /**
     * TXT record of host to verify ownership - if this record is removed, it may become unverified as this is checked periodically to continually verify ownership
     */
    'txt_verification': string;
    /**
     * UTC datetime when the host was verified (ISO 8601 date format).
     */
    'verified_at'?: string;
    'date': ModelDate;
    'verification_status': HostVerificationStatus;
}


/**
 * Host body
 */
export interface HostBody {
    /**
     * Hostname, this can be the root of a domain or a subdomain
     */
    'host': string;
    /**
     * The secret reference to the certificate
     */
    'certificate': string;
    /**
     * If the host is disabled, then this host won\'t be accessible and so the deployments will not be routable
     */
    'disabled': boolean;
}
/**
 * Host body update
 */
export interface HostBodyPatch {
    /**
     * The secret reference to the certificate
     */
    'certificate'?: string;
    /**
     * If the host is disabled, then this host won\'t be accessible and so the deployments will not be routable
     */
    'disabled'?: boolean;
}
/**
 * Host verification status
 */

export const HostVerificationStatus = {
    pending: 'pending',
    already_verified: 'already_verified',
    completed: 'completed',
    failed: 'failed'
} as const;

export type HostVerificationStatus = typeof HostVerificationStatus[keyof typeof HostVerificationStatus];


/**
 * List of functions
 */
export interface ListFunction {
    'meta': PaginationMeta;
    'data': Array<Function>;
}
/**
 * List of log
 */
export interface ListLogResponse {
    'meta': PaginationMeta;
    'data': Array<Log>;
}
/**
 * List of providers
 */
export interface ListProviderResponse {
    'meta': PaginationMeta;
    'data': Array<Provider>;
}
/**
 * Location of allowed clusters
 */
export interface Location {
    /**
     * UUID of provider to deploy into
     */
    'provider_id': string;
    /**
     * Deployment continent
     */
    'continent'?: string;
    /**
     * Deployment country
     */
    'country'?: string;
    /**
     * Deployment city
     */
    'city'?: string;
}
/**
 * List of logs
 */
export interface Log {
    /**
     * Container ID the log line is for
     */
    'container'?: string;
    /**
     * Function ID the log line is for
     */
    'function'?: string;
    /**
     * Project ID the log line is for
     */
    'project'?: string;
    /**
     * Organisation ID the log line is for
     */
    'organisation'?: string;
    /**
     * Group ID the log line is for
     */
    'group'?: string;
    'log'?: LogLog;
}
/**
 * Log item
 */
export interface LogLog {
    /**
     * Which log stream
     */
    'stream'?: LogLogStreamEnum;
    /**
     * If this was an event on the function or a log line
     */
    'kind'?: LogLogKindEnum;
    /**
     * An array of labels
     */
    'labels'?: Array<string>;
    /**
     * Log line type
     */
    'type'?: LogLogTypeEnum;
    /**
     * Log line
     */
    'line'?: string;
    /**
     * The date/time that this log was generated
     */
    'timestamp'?: string;
}

export const LogLogStreamEnum = {
    stdout: 'stdout',
    stderr: 'stderr'
} as const;

export type LogLogStreamEnum = typeof LogLogStreamEnum[keyof typeof LogLogStreamEnum];
export const LogLogKindEnum = {
    event: 'event',
    log: 'log'
} as const;

export type LogLogKindEnum = typeof LogLogKindEnum[keyof typeof LogLogKindEnum];
export const LogLogTypeEnum = {
    info: 'info',
    error: 'error'
} as const;

export type LogLogTypeEnum = typeof LogLogTypeEnum[keyof typeof LogLogTypeEnum];

export interface LogsListFTimestampsParameter {
    /**
     * Restrict to after this timestamp
     */
    'after'?: string;
    /**
     * Resitrct to before this timestamp
     */
    'before'?: string;
}
/**
 * Metric http aggregation
 */
export interface MetricHttpAggregation {
    'http_codes'?: MetricHttpAggregationHttpCodes;
}
/**
 * HTTP status code aggregation
 */
export interface MetricHttpAggregationHttpCodes {
    /**
     * Array of unique http status codes
     */
    'buckets'?: Array<MetricHttpAggregationHttpCodesBucketsInner>;
    /**
     * Upper bound of error in document count
     */
    'doc_count_error_upper_bound'?: number;
    /**
     * Sum of other document counts
     */
    'sum_other_doc_count'?: number;
}
/**
 * HTTP status code bucket
 */
export interface MetricHttpAggregationHttpCodesBucketsInner {
    /**
     * Number of documents in the bucket
     */
    'doc_count'?: number;
    'histogram'?: MetricHttpAggregationHttpCodesBucketsInnerHistogram;
    /**
     * HTTP status code, typical values will be;  - http-2xx - http-3xx - http-4xx - http-5xx  > Note: the \'xx\' is intentional and literal, all status codes within that range will be grouped 
     */
    'key'?: string;
}
/**
 * Histogram of http status code usage
 */
export interface MetricHttpAggregationHttpCodesBucketsInnerHistogram {
    /**
     * Array of resource usage by interval  > Note: A metric will have either a `counter` or `gauge` value 
     */
    'buckets'?: Array<MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInner>;
}
/**
 * Metric resource aggregation
 */
export interface MetricResourceAggregation {
    'resources'?: MetricResourceAggregationResources;
}
/**
 * Resource(s) aggregation
 */
export interface MetricResourceAggregationResources {
    /**
     * Array of unqiue resources
     */
    'buckets'?: Array<MetricResourceAggregationResourcesBucketsInner>;
    /**
     * Upper bound of error in document count
     */
    'doc_count_error_upper_bound'?: number;
    /**
     * Sum of other document counts
     */
    'sum_other_doc_count'?: number;
}
/**
 * Histogram bucket
 */
export interface MetricResourceAggregationResourcesBucketsInner {
    /**
     * Number of documents in the bucket
     */
    'doc_count'?: number;
    'histogram'?: MetricResourceAggregationResourcesBucketsInnerHistogram;
    /**
     * Metric key
     */
    'key'?: string;
}
/**
 * Histogram of resource usage
 */
export interface MetricResourceAggregationResourcesBucketsInnerHistogram {
    /**
     * Array of resource usage by interval  > Note: A metric will have either a `counter` or `gauge` value 
     */
    'buckets'?: Array<MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInner>;
}
export interface MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInner {
    /**
     * Number of documents in the bucket
     */
    'doc_count'?: number;
    'counter'?: MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInnerCounter;
    'gauge'?: MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInnerGauge;
    /**
     * Histogram key (typically unix timestamp)
     */
    'key'?: number;
    /**
     * Histogram key as string/date-time
     */
    'key_as_string'?: string;
}
/**
 * Counter (monotonically incrementing)
 */
export interface MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInnerCounter {
    /**
     * Average counter value
     */
    'avg'?: number | null;
    /**
     * Number of counter values
     */
    'count'?: number | null;
    /**
     * Maximum counter value
     */
    'max'?: number | null;
    /**
     * Minimum counter value
     */
    'min'?: number | null;
    /**
     * Sum of counter values
     */
    'sum'?: number | null;
}
/**
 * Gauge (value at a point in time)
 */
export interface MetricResourceAggregationResourcesBucketsInnerHistogramBucketsInnerGauge {
    /**
     * Average gauge value
     */
    'avg'?: number | null;
    /**
     * Number of gauge values
     */
    'count'?: number | null;
    /**
     * Maximum gauge value
     */
    'max'?: number | null;
    /**
     * Minimum gauge value
     */
    'min'?: number | null;
    /**
     * Sum of gauge values
     */
    'sum'?: number;
}
/**
 * @type MetricsAggregationsList200Response
 */
export type MetricsAggregationsList200Response = MetricHttpAggregation | MetricResourceAggregation;

/**
 * Object date information
 */
export interface ModelDate {
    /**
     * UTC creation datetime (ISO 8601 date format)
     */
    'created_at': string;
    /**
     * UTC update datetime (ISO 8601 date format)
     */
    'updated_at': string;
}
/**
 * Resource not found
 */
export interface NotFoundResponse {
    'message': string;
}
/**
 * Organisation response/object
 */
export interface Organisation {
    /**
     * Organisation id
     */
    'id': string;
    /**
     * User id
     */
    'user_id': string;
    /**
     * Organisation name
     */
    'name': string;
    'date': ModelDate;
}
/**
 * Organisation body
 */
export interface OrganisationBody {
    /**
     * Organisation name
     */
    'name': string;
}
export interface OrganisationsListPageParameter {
    /**
     * Offset
     */
    'before'?: number;
    /**
     * Offset
     */
    'after'?: number;
    /**
     * Limit
     */
    'size'?: number;
}
/**
 * Links object for pagination use
 */
export interface PaginationLinks {
    'prev': string;
    'next': string;
}
/**
 * Meta object for pagination use
 */
export interface PaginationMeta {
    'results': number;
    'start': number;
    'end': number;
    'pages': number;
    'links': PaginationLinks;
}
/**
 * Payment method
 */
export interface PaymentMethod {
    /**
     * Unique identifier for the payment method
     */
    'id'?: string;
    /**
     * Unique identifier for the billing account
     */
    'billing_account'?: string;
    /**
     * Name on the payment method
     */
    'name'?: string;
    /**
     * Current state of the payment method
     */
    'state'?: PaymentMethodStateEnum;
    'address'?: PaymentMethodAddress;
}

export const PaymentMethodStateEnum = {
    active: 'active',
    inactive: 'inactive',
    suspended: 'suspended',
    deleted: 'deleted'
} as const;

export type PaymentMethodStateEnum = typeof PaymentMethodStateEnum[keyof typeof PaymentMethodStateEnum];

/**
 * Billing address associated with the payment method
 */
export interface PaymentMethodAddress {
    /**
     * Title of the cardholder
     */
    'title'?: string;
    /**
     * First name of the cardholder
     */
    'first_name'?: string;
    /**
     * Last name of the cardholder
     */
    'last_name'?: string;
    /**
     * Organisation name, if applicable
     */
    'organisation'?: string;
    /**
     * First line of the address
     */
    'address_line1'?: string;
    /**
     * Second line of the address, if applicable
     */
    'address_line2'?: string;
    /**
     * City of the address
     */
    'city'?: string;
    /**
     * County or state of the address
     */
    'county'?: string;
    /**
     * Postal or ZIP code of the address
     */
    'postal_code'?: string;
    /**
     * Country of the address (ISO 3166-1 alpha-2 code)
     */
    'country'?: string;
    /**
     * Contact phone number associated with the payment method
     */
    'phone_number'?: string;
}
/**
 * Payment method body
 */
export interface PaymentMethodBody {
    /**
     * Name on the payment method
     */
    'name'?: string;
    /**
     * Title of the cardholder
     */
    'title'?: string;
    /**
     * First name of the cardholder
     */
    'first_name'?: string;
    /**
     * Last name of the cardholder
     */
    'last_name'?: string;
    /**
     * Organisation name, if applicable
     */
    'organisation'?: string;
    /**
     * First line of the address
     */
    'address_line1'?: string;
    /**
     * Second line of the address, if applicable
     */
    'address_line2'?: string;
    /**
     * City of the address
     */
    'city'?: string;
    /**
     * County or state of the address
     */
    'county'?: string;
    /**
     * Postal or ZIP code of the address
     */
    'postal_code'?: string;
    /**
     * Country of the address (ISO 3166-1 alpha-2 code)
     */
    'country'?: string;
    /**
     * Contact phone number associated with the payment method
     */
    'phone_number'?: string;
}
/**
 * Payment method create response
 */
export interface PaymentMethodCreate {
    /**
     * Unique identifier for the payment method
     */
    'payment_method_id'?: string;
    /**
     * Unique identifier for the billing account
     */
    'billing_account_id'?: string;
    /**
     * Name on the payment method
     */
    'name'?: string;
    /**
     * Description of this order (e.g. payment authorisation)
     */
    'description'?: string;
    /**
     * Current state of the payment method
     */
    'state'?: PaymentMethodCreateStateEnum;
    'links'?: PaymentMethodCreateLinks;
}

export const PaymentMethodCreateStateEnum = {
    active: 'active',
    inactive: 'inactive',
    suspended: 'suspended',
    deleted: 'deleted'
} as const;

export type PaymentMethodCreateStateEnum = typeof PaymentMethodCreateStateEnum[keyof typeof PaymentMethodCreateStateEnum];

/**
 * Links related to the payment method, such as checkout URL
 */
export interface PaymentMethodCreateLinks {
    /**
     * URL for the payment method checkout
     */
    'checkout'?: string;
    /**
     * Timestamp when the checkout link was created
     */
    'created_at'?: string;
    /**
     * Timestamp when the checkout link expires
     */
    'expires_at'?: string;
}
/**
 * Project response/object
 */
export interface Project {
    /**
     * Project id
     */
    'id': string;
    /**
     * Organisation id
     */
    'org_id': string;
    /**
     * Project name
     */
    'name': string;
    'date': ModelDate;
}
/**
 * Project body
 */
export interface ProjectBody {
    /**
     * Organisation id
     */
    'org_id': string;
    /**
     * Project name
     */
    'name': string;
}
/**
 * Project patch fields
 */
export interface ProjectBodyPatch {
    /**
     * Organisation id
     */
    'org_id'?: string;
    /**
     * Project name
     */
    'name'?: string;
}
/**
 * List of providers
 */
export interface Provider {
    'id': string;
    /**
     * Name of provider
     */
    'name': string;
    'locations': ProviderLocations;
}
/**
 * Locations at varying levels this provider operates within
 */
export interface ProviderLocations {
    'continents': Array<string>;
    'countries': Array<string>;
    'cities': Array<string>;
}
/**
 * Quota usage
 */
export interface Quota {
    /**
     * Quota name
     */
    'name': string;
    /**
     * Quota description
     */
    'description': string;
    /**
     * Quota limit
     */
    'limit': number;
    /**
     * Quota usage
     */
    'usage': number;
    /**
     * Quota type (group)
     */
    'type': string;
}
/**
 * Secret response/object
 */
export interface Secret {
    /**
     * Secret name
     */
    'name': string;
    'type': SecretCreateType;
    'payload'?: SecretPayload;
    /**
     * Secret revision
     */
    'revision': number;
    'date': ModelDate;
}


/**
 * Secret body
 */
export interface SecretBody {
    /**
     * Secret name
     */
    'name': string;
    'type': SecretCreateType;
    'payload': SecretCreatePayload;
    /**
     * Encryption entity
     */
    'encryption': string;
}


/**
 * Secret body patch fields
 */
export interface SecretBodyPatch {
    'type': SecretCreateType;
    'payload': SecretCreatePayload;
    /**
     * Encryption entity
     */
    'encryption': string;
}


/**
 * Encrypted SSL private key and plain certificate. Certificate expected in x509 pem format, key expected in pkcs8 or pkcs1 pem format. `type: certificate`
 */
export interface SecretCertificate {
    /**
     * Public certificate
     */
    'certificate': string;
    /**
     * Encrypted certificate private key
     */
    'certificate_value': string;
}
/**
 * @type SecretCreatePayload
 * Payload for secret
 */
export type SecretCreatePayload = SecretCertificate | SecretEnvironment | SecretRegistry;

/**
 * Secrets types: registry, certificate, environment
 */

export const SecretCreateType = {
    registry: 'registry',
    certificate: 'certificate',
    environment: 'environment'
} as const;

export type SecretCreateType = typeof SecretCreateType[keyof typeof SecretCreateType];


/**
 * Encrypted ENV secret, `type: environment`
 */
export interface SecretEnvironment {
    /**
     * Encrypted environment value
     */
    'environment_value': string;
}
/**
 * Secret metadata response/object
 */
export interface SecretMeta {
    /**
     * Secret name
     */
    'name': string;
    'type': SecretMetaType;
    'payload'?: SecretMetaPayload;
    /**
     * Secret revision
     */
    'revision': number;
    'date': ModelDate;
}


/**
 * Secret metadata certificate payload
 */
export interface SecretMetaCertificatePayload {
    /**
     * Public SSL certificate
     */
    'certificate': string;
}
/**
 * DEK secret, `type: dek`
 */
export interface SecretMetaDek {
    /**
     * Base64 encoded DEK public key
     */
    'public': string;
}
/**
 * @type SecretMetaPayload
 */
export type SecretMetaPayload = SecretMetaCertificatePayload | SecretMetaDek | SecretMetaRegistryPayload;

/**
 * Secret metadata registry payload
 */
export interface SecretMetaRegistryPayload {
    /**
     * Private registry domain/location, when using the private docker hub registry sepcify `docker.io` > Without http scheme 
     */
    'registry': string;
}
/**
 * Secrets types: registry, certificate, environment, dek
 */

export const SecretMetaType = {
    registry: 'registry',
    certificate: 'certificate',
    environment: 'environment',
    dek: 'dek'
} as const;

export type SecretMetaType = typeof SecretMetaType[keyof typeof SecretMetaType];


/**
 * @type SecretPayload
 */
export type SecretPayload = SecretMetaCertificatePayload | SecretMetaRegistryPayload;

/**
 * Encrypted private container registry, `type: registry`
 */
export interface SecretRegistry {
    /**
     * Private registry domain/location, when using the private docker hub registry sepcify `docker.io` > Without http scheme 
     */
    'registry': string;
    /**
     * Token used for auth to the registry
     */
    'registry_value': string;
}
/**
 * Unauthorised
 */
export interface UnauthorisedResponse {
    'message': string;
}

/**
 * BillingApi - axios parameter creator
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new payment method associated with a specific billing account.
         * @summary Create a new payment method for a billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {PaymentMethodBody} PaymentMethodBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPaymentMethodsCreate: async (billing_account_id: string, PaymentMethodBody: PaymentMethodBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billing_account_id' is not null or undefined
            assertParamExists('accountsPaymentMethodsCreate', 'billing_account_id', billing_account_id)
            // verify required parameter 'PaymentMethodBody' is not null or undefined
            assertParamExists('accountsPaymentMethodsCreate', 'PaymentMethodBody', PaymentMethodBody)
            const localVarPath = `/billing/accounts/{billing_account_id}/payment-methods`
                .replace(`{${"billing_account_id"}}`, encodeURIComponent(String(billing_account_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PaymentMethodBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of payment methods associated with a specific billing account.
         * @summary List payment methods for a billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPaymentMethodsList: async (billing_account_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billing_account_id' is not null or undefined
            assertParamExists('accountsPaymentMethodsList', 'billing_account_id', billing_account_id)
            const localVarPath = `/billing/accounts/{billing_account_id}/payment-methods`
                .replace(`{${"billing_account_id"}}`, encodeURIComponent(String(billing_account_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new billing account
         * @summary Create billing account
         * @param {BillingAccountBody} BillingAccountBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingAccountsCreate: async (BillingAccountBody: BillingAccountBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'BillingAccountBody' is not null or undefined
            assertParamExists('billingAccountsCreate', 'BillingAccountBody', BillingAccountBody)
            const localVarPath = `/billing/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(BillingAccountBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific billing account if it is no longer attached to any organizations or projects and has no outstanding balances or invoice payments.
         * @summary Delete billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingAccountsDelete: async (billing_account_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billing_account_id' is not null or undefined
            assertParamExists('billingAccountsDelete', 'billing_account_id', billing_account_id)
            const localVarPath = `/billing/accounts/{billing_account_id}`
                .replace(`{${"billing_account_id"}}`, encodeURIComponent(String(billing_account_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific billing account
         * @summary Get billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingAccountsGet: async (billing_account_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billing_account_id' is not null or undefined
            assertParamExists('billingAccountsGet', 'billing_account_id', billing_account_id)
            const localVarPath = `/billing/accounts/{billing_account_id}`
                .replace(`{${"billing_account_id"}}`, encodeURIComponent(String(billing_account_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all billing accounts for this user, paginated
         * @summary List billing accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingAccountsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of a specific billing account.
         * @summary Update billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {BillingAccountBody} BillingAccountBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingAccountsUpdate: async (billing_account_id: string, BillingAccountBody: BillingAccountBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billing_account_id' is not null or undefined
            assertParamExists('billingAccountsUpdate', 'billing_account_id', billing_account_id)
            // verify required parameter 'BillingAccountBody' is not null or undefined
            assertParamExists('billingAccountsUpdate', 'BillingAccountBody', BillingAccountBody)
            const localVarPath = `/billing/accounts/{billing_account_id}`
                .replace(`{${"billing_account_id"}}`, encodeURIComponent(String(billing_account_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(BillingAccountBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a specific payment method entirely if there are no associated resources and no pending partial invoices.
         * @summary Delete a specific payment method
         * @param {string} billing_payment_method_id Payment method ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentMethodsDelete: async (billing_payment_method_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billing_payment_method_id' is not null or undefined
            assertParamExists('paymentMethodsDelete', 'billing_payment_method_id', billing_payment_method_id)
            const localVarPath = `/billing/payment-methods/{billing_payment_method_id}`
                .replace(`{${"billing_payment_method_id"}}`, encodeURIComponent(String(billing_payment_method_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metadata (such as state, active, declined, cancelled, etc.) for a specific payment method.
         * @summary Retrieve metadata for a specific payment method
         * @param {string} billing_payment_method_id Payment method ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentMethodsGet: async (billing_payment_method_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billing_payment_method_id' is not null or undefined
            assertParamExists('paymentMethodsGet', 'billing_payment_method_id', billing_payment_method_id)
            const localVarPath = `/billing/payment-methods/{billing_payment_method_id}`
                .replace(`{${"billing_payment_method_id"}}`, encodeURIComponent(String(billing_payment_method_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of a specific payment method.
         * @summary Update a specific payment method
         * @param {string} billing_payment_method_id Payment method ID reference
         * @param {PaymentMethodBody} PaymentMethodBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentMethodsUpdate: async (billing_payment_method_id: string, PaymentMethodBody: PaymentMethodBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billing_payment_method_id' is not null or undefined
            assertParamExists('paymentMethodsUpdate', 'billing_payment_method_id', billing_payment_method_id)
            // verify required parameter 'PaymentMethodBody' is not null or undefined
            assertParamExists('paymentMethodsUpdate', 'PaymentMethodBody', PaymentMethodBody)
            const localVarPath = `/billing/payment-methods/{billing_payment_method_id}`
                .replace(`{${"billing_payment_method_id"}}`, encodeURIComponent(String(billing_payment_method_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PaymentMethodBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new payment method associated with a specific billing account.
         * @summary Create a new payment method for a billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {PaymentMethodBody} PaymentMethodBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPaymentMethodsCreate(billing_account_id: string, PaymentMethodBody: PaymentMethodBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPaymentMethodsCreate(billing_account_id, PaymentMethodBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.accountsPaymentMethodsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of payment methods associated with a specific billing account.
         * @summary List payment methods for a billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPaymentMethodsList(billing_account_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentMethod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPaymentMethodsList(billing_account_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.accountsPaymentMethodsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new billing account
         * @summary Create billing account
         * @param {BillingAccountBody} BillingAccountBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingAccountsCreate(BillingAccountBody: BillingAccountBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingAccountsCreate(BillingAccountBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.billingAccountsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific billing account if it is no longer attached to any organizations or projects and has no outstanding balances or invoice payments.
         * @summary Delete billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingAccountsDelete(billing_account_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingAccountsDelete(billing_account_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.billingAccountsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific billing account
         * @summary Get billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingAccountsGet(billing_account_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingAccountsGet(billing_account_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.billingAccountsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all billing accounts for this user, paginated
         * @summary List billing accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingAccountsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BillingAccount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingAccountsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.billingAccountsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of a specific billing account.
         * @summary Update billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {BillingAccountBody} BillingAccountBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingAccountsUpdate(billing_account_id: string, BillingAccountBody: BillingAccountBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingAccountsUpdate(billing_account_id, BillingAccountBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.billingAccountsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a specific payment method entirely if there are no associated resources and no pending partial invoices.
         * @summary Delete a specific payment method
         * @param {string} billing_payment_method_id Payment method ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentMethodsDelete(billing_payment_method_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentMethodsDelete(billing_payment_method_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.paymentMethodsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get metadata (such as state, active, declined, cancelled, etc.) for a specific payment method.
         * @summary Retrieve metadata for a specific payment method
         * @param {string} billing_payment_method_id Payment method ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentMethodsGet(billing_payment_method_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentMethodsGet(billing_payment_method_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.paymentMethodsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of a specific payment method.
         * @summary Update a specific payment method
         * @param {string} billing_payment_method_id Payment method ID reference
         * @param {PaymentMethodBody} PaymentMethodBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentMethodsUpdate(billing_payment_method_id: string, PaymentMethodBody: PaymentMethodBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentMethodsUpdate(billing_payment_method_id, PaymentMethodBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.paymentMethodsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingApi - factory interface
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * Create a new payment method associated with a specific billing account.
         * @summary Create a new payment method for a billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {PaymentMethodBody} PaymentMethodBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPaymentMethodsCreate(billing_account_id: string, PaymentMethodBody: PaymentMethodBody, options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethodCreate> {
            return localVarFp.accountsPaymentMethodsCreate(billing_account_id, PaymentMethodBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of payment methods associated with a specific billing account.
         * @summary List payment methods for a billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPaymentMethodsList(billing_account_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PaymentMethod>> {
            return localVarFp.accountsPaymentMethodsList(billing_account_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new billing account
         * @summary Create billing account
         * @param {BillingAccountBody} BillingAccountBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingAccountsCreate(BillingAccountBody: BillingAccountBody, options?: RawAxiosRequestConfig): AxiosPromise<BillingAccount> {
            return localVarFp.billingAccountsCreate(BillingAccountBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific billing account if it is no longer attached to any organizations or projects and has no outstanding balances or invoice payments.
         * @summary Delete billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingAccountsDelete(billing_account_id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse> {
            return localVarFp.billingAccountsDelete(billing_account_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific billing account
         * @summary Get billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingAccountsGet(billing_account_id: string, options?: RawAxiosRequestConfig): AxiosPromise<BillingAccount> {
            return localVarFp.billingAccountsGet(billing_account_id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all billing accounts for this user, paginated
         * @summary List billing accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingAccountsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<BillingAccount>> {
            return localVarFp.billingAccountsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of a specific billing account.
         * @summary Update billing account
         * @param {string} billing_account_id Billing account ID reference
         * @param {BillingAccountBody} BillingAccountBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingAccountsUpdate(billing_account_id: string, BillingAccountBody: BillingAccountBody, options?: RawAxiosRequestConfig): AxiosPromise<BillingAccount> {
            return localVarFp.billingAccountsUpdate(billing_account_id, BillingAccountBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a specific payment method entirely if there are no associated resources and no pending partial invoices.
         * @summary Delete a specific payment method
         * @param {string} billing_payment_method_id Payment method ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentMethodsDelete(billing_payment_method_id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse> {
            return localVarFp.paymentMethodsDelete(billing_payment_method_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get metadata (such as state, active, declined, cancelled, etc.) for a specific payment method.
         * @summary Retrieve metadata for a specific payment method
         * @param {string} billing_payment_method_id Payment method ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentMethodsGet(billing_payment_method_id: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethod> {
            return localVarFp.paymentMethodsGet(billing_payment_method_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of a specific payment method.
         * @summary Update a specific payment method
         * @param {string} billing_payment_method_id Payment method ID reference
         * @param {PaymentMethodBody} PaymentMethodBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentMethodsUpdate(billing_payment_method_id: string, PaymentMethodBody: PaymentMethodBody, options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethod> {
            return localVarFp.paymentMethodsUpdate(billing_payment_method_id, PaymentMethodBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 */
export class BillingApi extends BaseAPI {
    /**
     * Create a new payment method associated with a specific billing account.
     * @summary Create a new payment method for a billing account
     * @param {string} billing_account_id Billing account ID reference
     * @param {PaymentMethodBody} PaymentMethodBody Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public accountsPaymentMethodsCreate(billing_account_id: string, PaymentMethodBody: PaymentMethodBody, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).accountsPaymentMethodsCreate(billing_account_id, PaymentMethodBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of payment methods associated with a specific billing account.
     * @summary List payment methods for a billing account
     * @param {string} billing_account_id Billing account ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public accountsPaymentMethodsList(billing_account_id: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).accountsPaymentMethodsList(billing_account_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new billing account
     * @summary Create billing account
     * @param {BillingAccountBody} BillingAccountBody Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingAccountsCreate(BillingAccountBody: BillingAccountBody, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).billingAccountsCreate(BillingAccountBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific billing account if it is no longer attached to any organizations or projects and has no outstanding balances or invoice payments.
     * @summary Delete billing account
     * @param {string} billing_account_id Billing account ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingAccountsDelete(billing_account_id: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).billingAccountsDelete(billing_account_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific billing account
     * @summary Get billing account
     * @param {string} billing_account_id Billing account ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingAccountsGet(billing_account_id: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).billingAccountsGet(billing_account_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all billing accounts for this user, paginated
     * @summary List billing accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingAccountsList(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).billingAccountsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of a specific billing account.
     * @summary Update billing account
     * @param {string} billing_account_id Billing account ID reference
     * @param {BillingAccountBody} BillingAccountBody Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingAccountsUpdate(billing_account_id: string, BillingAccountBody: BillingAccountBody, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).billingAccountsUpdate(billing_account_id, BillingAccountBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a specific payment method entirely if there are no associated resources and no pending partial invoices.
     * @summary Delete a specific payment method
     * @param {string} billing_payment_method_id Payment method ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentMethodsDelete(billing_payment_method_id: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).paymentMethodsDelete(billing_payment_method_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get metadata (such as state, active, declined, cancelled, etc.) for a specific payment method.
     * @summary Retrieve metadata for a specific payment method
     * @param {string} billing_payment_method_id Payment method ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentMethodsGet(billing_payment_method_id: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).paymentMethodsGet(billing_payment_method_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of a specific payment method.
     * @summary Update a specific payment method
     * @param {string} billing_payment_method_id Payment method ID reference
     * @param {PaymentMethodBody} PaymentMethodBody Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentMethodsUpdate(billing_payment_method_id: string, PaymentMethodBody: PaymentMethodBody, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).paymentMethodsUpdate(billing_payment_method_id, PaymentMethodBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FunctionsApi - axios parameter creator
 */
export const FunctionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new function
         * @summary Create function
         * @param {FunctionBody} FunctionBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsCreate: async (FunctionBody: FunctionBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'FunctionBody' is not null or undefined
            assertParamExists('functionsCreate', 'FunctionBody', FunctionBody)
            const localVarPath = `/functions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(FunctionBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a function (and all revisions)
         * @summary Delete function
         * @param {string} function_id Function ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsDelete: async (function_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'function_id' is not null or undefined
            assertParamExists('functionsDelete', 'function_id', function_id)
            const localVarPath = `/functions/{function_id}`
                .replace(`{${"function_id"}}`, encodeURIComponent(String(function_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific function (latest revision)
         * @summary Get function (latest revision)
         * @param {string} function_id Function ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsGet: async (function_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'function_id' is not null or undefined
            assertParamExists('functionsGet', 'function_id', function_id)
            const localVarPath = `/functions/{function_id}`
                .replace(`{${"function_id"}}`, encodeURIComponent(String(function_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific revision of a function
         * @summary Get a specific revision of a function
         * @param {string} function_id Function ID reference
         * @param {string} function_revision_id Function revision ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsRevisionsGet: async (function_id: string, function_revision_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'function_id' is not null or undefined
            assertParamExists('functionsRevisionsGet', 'function_id', function_id)
            // verify required parameter 'function_revision_id' is not null or undefined
            assertParamExists('functionsRevisionsGet', 'function_revision_id', function_revision_id)
            const localVarPath = `/functions/{function_id}/revisions/{function_revision_id}`
                .replace(`{${"function_id"}}`, encodeURIComponent(String(function_id)))
                .replace(`{${"function_revision_id"}}`, encodeURIComponent(String(function_revision_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all revisions for a function
         * @summary List all revisions for a function
         * @param {string} function_id Function ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsRevisionsList: async (function_id: string, page?: OrganisationsListPageParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'function_id' is not null or undefined
            assertParamExists('functionsRevisionsList', 'function_id', function_id)
            const localVarPath = `/functions/{function_id}/revisions`
                .replace(`{${"function_id"}}`, encodeURIComponent(String(function_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                for (const [key, value] of Object.entries(page)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a function (creates a new revision)
         * @summary Update function
         * @param {string} function_id Function ID reference
         * @param {Function} Function Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsUpdate: async (function_id: string, Function: Function, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'function_id' is not null or undefined
            assertParamExists('functionsUpdate', 'function_id', function_id)
            // verify required parameter 'Function' is not null or undefined
            assertParamExists('functionsUpdate', 'Function', Function)
            const localVarPath = `/functions/{function_id}`
                .replace(`{${"function_id"}}`, encodeURIComponent(String(function_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(Function, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all functions
         * @summary List all functions within a project
         * @param {string} project_id Project ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsFunctionsList: async (project_id: string, page?: OrganisationsListPageParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsFunctionsList', 'project_id', project_id)
            const localVarPath = `/projects/{project_id}/functions`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                for (const [key, value] of Object.entries(page)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FunctionsApi - functional programming interface
 */
export const FunctionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FunctionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new function
         * @summary Create function
         * @param {FunctionBody} FunctionBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsCreate(FunctionBody: FunctionBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Function>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsCreate(FunctionBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FunctionsApi.functionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a function (and all revisions)
         * @summary Delete function
         * @param {string} function_id Function ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsDelete(function_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsDelete(function_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FunctionsApi.functionsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific function (latest revision)
         * @summary Get function (latest revision)
         * @param {string} function_id Function ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsGet(function_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Function>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsGet(function_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FunctionsApi.functionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific revision of a function
         * @summary Get a specific revision of a function
         * @param {string} function_id Function ID reference
         * @param {string} function_revision_id Function revision ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsRevisionsGet(function_id: string, function_revision_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Function>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsRevisionsGet(function_id, function_revision_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FunctionsApi.functionsRevisionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all revisions for a function
         * @summary List all revisions for a function
         * @param {string} function_id Function ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsRevisionsList(function_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFunction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsRevisionsList(function_id, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FunctionsApi.functionsRevisionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a function (creates a new revision)
         * @summary Update function
         * @param {string} function_id Function ID reference
         * @param {Function} Function Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsUpdate(function_id: string, Function: Function, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Function>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsUpdate(function_id, Function, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FunctionsApi.functionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all functions
         * @summary List all functions within a project
         * @param {string} project_id Project ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsFunctionsList(project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFunction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsFunctionsList(project_id, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FunctionsApi.projectsFunctionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FunctionsApi - factory interface
 */
export const FunctionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FunctionsApiFp(configuration)
    return {
        /**
         * Create a new function
         * @summary Create function
         * @param {FunctionBody} FunctionBody Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsCreate(FunctionBody: FunctionBody, options?: RawAxiosRequestConfig): AxiosPromise<Function> {
            return localVarFp.functionsCreate(FunctionBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a function (and all revisions)
         * @summary Delete function
         * @param {string} function_id Function ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsDelete(function_id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse> {
            return localVarFp.functionsDelete(function_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific function (latest revision)
         * @summary Get function (latest revision)
         * @param {string} function_id Function ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsGet(function_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Function> {
            return localVarFp.functionsGet(function_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific revision of a function
         * @summary Get a specific revision of a function
         * @param {string} function_id Function ID reference
         * @param {string} function_revision_id Function revision ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsRevisionsGet(function_id: string, function_revision_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Function> {
            return localVarFp.functionsRevisionsGet(function_id, function_revision_id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all revisions for a function
         * @summary List all revisions for a function
         * @param {string} function_id Function ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsRevisionsList(function_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): AxiosPromise<ListFunction> {
            return localVarFp.functionsRevisionsList(function_id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a function (creates a new revision)
         * @summary Update function
         * @param {string} function_id Function ID reference
         * @param {Function} Function Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsUpdate(function_id: string, Function: Function, options?: RawAxiosRequestConfig): AxiosPromise<Function> {
            return localVarFp.functionsUpdate(function_id, Function, options).then((request) => request(axios, basePath));
        },
        /**
         * List all functions
         * @summary List all functions within a project
         * @param {string} project_id Project ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsFunctionsList(project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): AxiosPromise<ListFunction> {
            return localVarFp.projectsFunctionsList(project_id, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FunctionsApi - object-oriented interface
 */
export class FunctionsApi extends BaseAPI {
    /**
     * Create a new function
     * @summary Create function
     * @param {FunctionBody} FunctionBody Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public functionsCreate(FunctionBody: FunctionBody, options?: RawAxiosRequestConfig) {
        return FunctionsApiFp(this.configuration).functionsCreate(FunctionBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a function (and all revisions)
     * @summary Delete function
     * @param {string} function_id Function ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public functionsDelete(function_id: string, options?: RawAxiosRequestConfig) {
        return FunctionsApiFp(this.configuration).functionsDelete(function_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific function (latest revision)
     * @summary Get function (latest revision)
     * @param {string} function_id Function ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public functionsGet(function_id: string, options?: RawAxiosRequestConfig) {
        return FunctionsApiFp(this.configuration).functionsGet(function_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific revision of a function
     * @summary Get a specific revision of a function
     * @param {string} function_id Function ID reference
     * @param {string} function_revision_id Function revision ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public functionsRevisionsGet(function_id: string, function_revision_id: string, options?: RawAxiosRequestConfig) {
        return FunctionsApiFp(this.configuration).functionsRevisionsGet(function_id, function_revision_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all revisions for a function
     * @summary List all revisions for a function
     * @param {string} function_id Function ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public functionsRevisionsList(function_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig) {
        return FunctionsApiFp(this.configuration).functionsRevisionsList(function_id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a function (creates a new revision)
     * @summary Update function
     * @param {string} function_id Function ID reference
     * @param {Function} Function Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public functionsUpdate(function_id: string, Function: Function, options?: RawAxiosRequestConfig) {
        return FunctionsApiFp(this.configuration).functionsUpdate(function_id, Function, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all functions
     * @summary List all functions within a project
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsFunctionsList(project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig) {
        return FunctionsApiFp(this.configuration).projectsFunctionsList(project_id, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HostsApi - axios parameter creator
 */
export const HostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assign a host/domain to a project - hosts are globally unique and require verification, so a host cannot be assigned to multiple projects.  A host can be a valid domain, either a root domain or a subdomain. 
         * @summary Create host for project
         * @param {string} project_id Project ID reference
         * @param {HostBody} HostBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHostsCreate: async (project_id: string, HostBody: HostBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsHostsCreate', 'project_id', project_id)
            // verify required parameter 'HostBody' is not null or undefined
            assertParamExists('projectsHostsCreate', 'HostBody', HostBody)
            const localVarPath = `/projects/{project_id}/hosts`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(HostBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete specific host by hostname
         * @param {string} project_id Project ID reference
         * @param {string} hostname Hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHostsDelete: async (project_id: string, hostname: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsHostsDelete', 'project_id', project_id)
            // verify required parameter 'hostname' is not null or undefined
            assertParamExists('projectsHostsDelete', 'hostname', hostname)
            const localVarPath = `/projects/{project_id}/hosts/{hostname}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)))
                .replace(`{${"hostname"}}`, encodeURIComponent(String(hostname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get specific host by hostname
         * @param {string} project_id Project ID reference
         * @param {string} hostname Hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHostsGet: async (project_id: string, hostname: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsHostsGet', 'project_id', project_id)
            // verify required parameter 'hostname' is not null or undefined
            assertParamExists('projectsHostsGet', 'hostname', hostname)
            const localVarPath = `/projects/{project_id}/hosts/{hostname}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)))
                .replace(`{${"hostname"}}`, encodeURIComponent(String(hostname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List hosts for project
         * @param {string} project_id Project ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHostsList: async (project_id: string, page?: OrganisationsListPageParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsHostsList', 'project_id', project_id)
            const localVarPath = `/projects/{project_id}/hosts`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                for (const [key, value] of Object.entries(page)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update specific host by hostname
         * @param {string} project_id Project ID reference
         * @param {string} hostname Hostname
         * @param {HostBodyPatch} HostBodyPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHostsUpdate: async (project_id: string, hostname: string, HostBodyPatch: HostBodyPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsHostsUpdate', 'project_id', project_id)
            // verify required parameter 'hostname' is not null or undefined
            assertParamExists('projectsHostsUpdate', 'hostname', hostname)
            // verify required parameter 'HostBodyPatch' is not null or undefined
            assertParamExists('projectsHostsUpdate', 'HostBodyPatch', HostBodyPatch)
            const localVarPath = `/projects/{project_id}/hosts/{hostname}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)))
                .replace(`{${"hostname"}}`, encodeURIComponent(String(hostname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(HostBodyPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Schedule host verification task
         * @param {string} project_id Project ID reference
         * @param {string} hostname Hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHostsVerifyCreate: async (project_id: string, hostname: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsHostsVerifyCreate', 'project_id', project_id)
            // verify required parameter 'hostname' is not null or undefined
            assertParamExists('projectsHostsVerifyCreate', 'hostname', hostname)
            const localVarPath = `/projects/{project_id}/hosts/{hostname}/verify`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)))
                .replace(`{${"hostname"}}`, encodeURIComponent(String(hostname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HostsApi - functional programming interface
 */
export const HostsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HostsApiAxiosParamCreator(configuration)
    return {
        /**
         * Assign a host/domain to a project - hosts are globally unique and require verification, so a host cannot be assigned to multiple projects.  A host can be a valid domain, either a root domain or a subdomain. 
         * @summary Create host for project
         * @param {string} project_id Project ID reference
         * @param {HostBody} HostBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsHostsCreate(project_id: string, HostBody: HostBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsHostsCreate(project_id, HostBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostsApi.projectsHostsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete specific host by hostname
         * @param {string} project_id Project ID reference
         * @param {string} hostname Hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsHostsDelete(project_id: string, hostname: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsHostsDelete(project_id, hostname, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostsApi.projectsHostsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get specific host by hostname
         * @param {string} project_id Project ID reference
         * @param {string} hostname Hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsHostsGet(project_id: string, hostname: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsHostsGet(project_id, hostname, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostsApi.projectsHostsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List hosts for project
         * @param {string} project_id Project ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsHostsList(project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Host>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsHostsList(project_id, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostsApi.projectsHostsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update specific host by hostname
         * @param {string} project_id Project ID reference
         * @param {string} hostname Hostname
         * @param {HostBodyPatch} HostBodyPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsHostsUpdate(project_id: string, hostname: string, HostBodyPatch: HostBodyPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsHostsUpdate(project_id, hostname, HostBodyPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostsApi.projectsHostsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Schedule host verification task
         * @param {string} project_id Project ID reference
         * @param {string} hostname Hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsHostsVerifyCreate(project_id: string, hostname: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsHostsVerifyCreate(project_id, hostname, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostsApi.projectsHostsVerifyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HostsApi - factory interface
 */
export const HostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HostsApiFp(configuration)
    return {
        /**
         * Assign a host/domain to a project - hosts are globally unique and require verification, so a host cannot be assigned to multiple projects.  A host can be a valid domain, either a root domain or a subdomain. 
         * @summary Create host for project
         * @param {string} project_id Project ID reference
         * @param {HostBody} HostBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHostsCreate(project_id: string, HostBody: HostBody, options?: RawAxiosRequestConfig): AxiosPromise<Host> {
            return localVarFp.projectsHostsCreate(project_id, HostBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete specific host by hostname
         * @param {string} project_id Project ID reference
         * @param {string} hostname Hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHostsDelete(project_id: string, hostname: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse> {
            return localVarFp.projectsHostsDelete(project_id, hostname, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get specific host by hostname
         * @param {string} project_id Project ID reference
         * @param {string} hostname Hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHostsGet(project_id: string, hostname: string, options?: RawAxiosRequestConfig): AxiosPromise<Host> {
            return localVarFp.projectsHostsGet(project_id, hostname, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List hosts for project
         * @param {string} project_id Project ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHostsList(project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<Host>> {
            return localVarFp.projectsHostsList(project_id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update specific host by hostname
         * @param {string} project_id Project ID reference
         * @param {string} hostname Hostname
         * @param {HostBodyPatch} HostBodyPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHostsUpdate(project_id: string, hostname: string, HostBodyPatch: HostBodyPatch, options?: RawAxiosRequestConfig): AxiosPromise<Host> {
            return localVarFp.projectsHostsUpdate(project_id, hostname, HostBodyPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Schedule host verification task
         * @param {string} project_id Project ID reference
         * @param {string} hostname Hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHostsVerifyCreate(project_id: string, hostname: string, options?: RawAxiosRequestConfig): AxiosPromise<Host> {
            return localVarFp.projectsHostsVerifyCreate(project_id, hostname, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HostsApi - object-oriented interface
 */
export class HostsApi extends BaseAPI {
    /**
     * Assign a host/domain to a project - hosts are globally unique and require verification, so a host cannot be assigned to multiple projects.  A host can be a valid domain, either a root domain or a subdomain. 
     * @summary Create host for project
     * @param {string} project_id Project ID reference
     * @param {HostBody} HostBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsHostsCreate(project_id: string, HostBody: HostBody, options?: RawAxiosRequestConfig) {
        return HostsApiFp(this.configuration).projectsHostsCreate(project_id, HostBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsHostsDelete(project_id: string, hostname: string, options?: RawAxiosRequestConfig) {
        return HostsApiFp(this.configuration).projectsHostsDelete(project_id, hostname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsHostsGet(project_id: string, hostname: string, options?: RawAxiosRequestConfig) {
        return HostsApiFp(this.configuration).projectsHostsGet(project_id, hostname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List hosts for project
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsHostsList(project_id: string, page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig) {
        return HostsApiFp(this.configuration).projectsHostsList(project_id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update specific host by hostname
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {HostBodyPatch} HostBodyPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsHostsUpdate(project_id: string, hostname: string, HostBodyPatch: HostBodyPatch, options?: RawAxiosRequestConfig) {
        return HostsApiFp(this.configuration).projectsHostsUpdate(project_id, hostname, HostBodyPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Schedule host verification task
     * @param {string} project_id Project ID reference
     * @param {string} hostname Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsHostsVerifyCreate(project_id: string, hostname: string, options?: RawAxiosRequestConfig) {
        return HostsApiFp(this.configuration).projectsHostsVerifyCreate(project_id, hostname, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogsApi - axios parameter creator
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve logs for a specific project or function. Use the query parameter to search logs.  > Note: Logs are always returned in a descending order based on the timestamp. > Note: A max size of 500 logs is returned per request (when using page[size]). 
         * @summary Get logs
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {string} [f_project] Project uuid reference
         * @param {string} [f_function] Function uuid reference
         * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
         * @param {string} [f_query] Text query string
         * @param {LogsListFLogTypeEnum} [f_log_type] Type of log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsList: async (page?: OrganisationsListPageParameter, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_query?: string, f_log_type?: LogsListFLogTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                for (const [key, value] of Object.entries(page)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (f_project !== undefined) {
                localVarQueryParameter['f_project'] = f_project;
            }

            if (f_function !== undefined) {
                localVarQueryParameter['f_function'] = f_function;
            }

            if (f_timestamps !== undefined) {
                for (const [key, value] of Object.entries(f_timestamps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (f_query !== undefined) {
                localVarQueryParameter['f_query'] = f_query;
            }

            if (f_log_type !== undefined) {
                localVarQueryParameter['f_log_type'] = f_log_type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 */
export const LogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve logs for a specific project or function. Use the query parameter to search logs.  > Note: Logs are always returned in a descending order based on the timestamp. > Note: A max size of 500 logs is returned per request (when using page[size]). 
         * @summary Get logs
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {string} [f_project] Project uuid reference
         * @param {string} [f_function] Function uuid reference
         * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
         * @param {string} [f_query] Text query string
         * @param {LogsListFLogTypeEnum} [f_log_type] Type of log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsList(page?: OrganisationsListPageParameter, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_query?: string, f_log_type?: LogsListFLogTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListLogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsList(page, f_project, f_function, f_timestamps, f_query, f_log_type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.logsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogsApi - factory interface
 */
export const LogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsApiFp(configuration)
    return {
        /**
         * Retrieve logs for a specific project or function. Use the query parameter to search logs.  > Note: Logs are always returned in a descending order based on the timestamp. > Note: A max size of 500 logs is returned per request (when using page[size]). 
         * @summary Get logs
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {string} [f_project] Project uuid reference
         * @param {string} [f_function] Function uuid reference
         * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
         * @param {string} [f_query] Text query string
         * @param {LogsListFLogTypeEnum} [f_log_type] Type of log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsList(page?: OrganisationsListPageParameter, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_query?: string, f_log_type?: LogsListFLogTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListLogResponse> {
            return localVarFp.logsList(page, f_project, f_function, f_timestamps, f_query, f_log_type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogsApi - object-oriented interface
 */
export class LogsApi extends BaseAPI {
    /**
     * Retrieve logs for a specific project or function. Use the query parameter to search logs.  > Note: Logs are always returned in a descending order based on the timestamp. > Note: A max size of 500 logs is returned per request (when using page[size]). 
     * @summary Get logs
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_project] Project uuid reference
     * @param {string} [f_function] Function uuid reference
     * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
     * @param {string} [f_query] Text query string
     * @param {LogsListFLogTypeEnum} [f_log_type] Type of log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logsList(page?: OrganisationsListPageParameter, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_query?: string, f_log_type?: LogsListFLogTypeEnum, options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).logsList(page, f_project, f_function, f_timestamps, f_query, f_log_type, options).then((request) => request(this.axios, this.basePath));
    }
}

export const LogsListFLogTypeEnum = {
    info: 'info',
    error: 'error'
} as const;
export type LogsListFLogTypeEnum = typeof LogsListFLogTypeEnum[keyof typeof LogsListFLogTypeEnum];


/**
 * MetricsApi - axios parameter creator
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve metrics for a specific project or function. Use the query parameter to request a metrics report.  > Note: Metrics are always returned in a descending order based on the timestamp. 
         * @summary Get metrics
         * @param {MetricsAggregationsListMetricAggregationTypeEnum} metric_aggregation_type Metric aggregation type, types can be used with either a project or a function filter.  - httprequests: Aggregated HTTP requests - resourcestats: Aggregated resource stats (such as CPU, Memory and Network)  &gt; Note: aggregations cannot return more than 300 data points 
         * @param {string} [f_project] Project uuid reference
         * @param {string} [f_function] Function uuid reference
         * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
         * @param {number} [f_histogram_interval] Histogram interval
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsAggregationsList: async (metric_aggregation_type: MetricsAggregationsListMetricAggregationTypeEnum, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_histogram_interval?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metric_aggregation_type' is not null or undefined
            assertParamExists('metricsAggregationsList', 'metric_aggregation_type', metric_aggregation_type)
            const localVarPath = `/metrics/aggregations/{metric_aggregation_type}`
                .replace(`{${"metric_aggregation_type"}}`, encodeURIComponent(String(metric_aggregation_type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (f_project !== undefined) {
                localVarQueryParameter['f_project'] = f_project;
            }

            if (f_function !== undefined) {
                localVarQueryParameter['f_function'] = f_function;
            }

            if (f_timestamps !== undefined) {
                for (const [key, value] of Object.entries(f_timestamps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (f_histogram_interval !== undefined) {
                localVarQueryParameter['f_histogram_interval'] = f_histogram_interval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve metrics for a specific project or function. Use the query parameter to request a metrics report.  > Note: Metrics are always returned in a descending order based on the timestamp. 
         * @summary Get metrics
         * @param {MetricsAggregationsListMetricAggregationTypeEnum} metric_aggregation_type Metric aggregation type, types can be used with either a project or a function filter.  - httprequests: Aggregated HTTP requests - resourcestats: Aggregated resource stats (such as CPU, Memory and Network)  &gt; Note: aggregations cannot return more than 300 data points 
         * @param {string} [f_project] Project uuid reference
         * @param {string} [f_function] Function uuid reference
         * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
         * @param {number} [f_histogram_interval] Histogram interval
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsAggregationsList(metric_aggregation_type: MetricsAggregationsListMetricAggregationTypeEnum, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_histogram_interval?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsAggregationsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsAggregationsList(metric_aggregation_type, f_project, f_function, f_timestamps, f_histogram_interval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsAggregationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetricsApi - factory interface
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Retrieve metrics for a specific project or function. Use the query parameter to request a metrics report.  > Note: Metrics are always returned in a descending order based on the timestamp. 
         * @summary Get metrics
         * @param {MetricsAggregationsListMetricAggregationTypeEnum} metric_aggregation_type Metric aggregation type, types can be used with either a project or a function filter.  - httprequests: Aggregated HTTP requests - resourcestats: Aggregated resource stats (such as CPU, Memory and Network)  &gt; Note: aggregations cannot return more than 300 data points 
         * @param {string} [f_project] Project uuid reference
         * @param {string} [f_function] Function uuid reference
         * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
         * @param {number} [f_histogram_interval] Histogram interval
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsAggregationsList(metric_aggregation_type: MetricsAggregationsListMetricAggregationTypeEnum, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_histogram_interval?: number, options?: RawAxiosRequestConfig): AxiosPromise<MetricsAggregationsList200Response> {
            return localVarFp.metricsAggregationsList(metric_aggregation_type, f_project, f_function, f_timestamps, f_histogram_interval, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 */
export class MetricsApi extends BaseAPI {
    /**
     * Retrieve metrics for a specific project or function. Use the query parameter to request a metrics report.  > Note: Metrics are always returned in a descending order based on the timestamp. 
     * @summary Get metrics
     * @param {MetricsAggregationsListMetricAggregationTypeEnum} metric_aggregation_type Metric aggregation type, types can be used with either a project or a function filter.  - httprequests: Aggregated HTTP requests - resourcestats: Aggregated resource stats (such as CPU, Memory and Network)  &gt; Note: aggregations cannot return more than 300 data points 
     * @param {string} [f_project] Project uuid reference
     * @param {string} [f_function] Function uuid reference
     * @param {LogsListFTimestampsParameter} [f_timestamps] Timestamp restriction for query
     * @param {number} [f_histogram_interval] Histogram interval
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metricsAggregationsList(metric_aggregation_type: MetricsAggregationsListMetricAggregationTypeEnum, f_project?: string, f_function?: string, f_timestamps?: LogsListFTimestampsParameter, f_histogram_interval?: number, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsAggregationsList(metric_aggregation_type, f_project, f_function, f_timestamps, f_histogram_interval, options).then((request) => request(this.axios, this.basePath));
    }
}

export const MetricsAggregationsListMetricAggregationTypeEnum = {
    httprequests: 'httprequests',
    resourcestats: 'resourcestats'
} as const;
export type MetricsAggregationsListMetricAggregationTypeEnum = typeof MetricsAggregationsListMetricAggregationTypeEnum[keyof typeof MetricsAggregationsListMetricAggregationTypeEnum];


/**
 * OrganisationsApi - axios parameter creator
 */
export const OrganisationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organisation
         * @summary Create organisations
         * @param {OrganisationBody} [OrganisationBody] Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsCreate: async (OrganisationBody?: OrganisationBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organisations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(OrganisationBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organisation, this will also delete all the resources within the organisation
         * @summary Delete an organisation
         * @param {string} organisation_id Organisation ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsDelete: async (organisation_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation_id' is not null or undefined
            assertParamExists('organisationsDelete', 'organisation_id', organisation_id)
            const localVarPath = `/organisations/{organisation_id}`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisation_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single organisation
         * @summary Get an organisation
         * @param {string} organisation_id Organisation ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsGet: async (organisation_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation_id' is not null or undefined
            assertParamExists('organisationsGet', 'organisation_id', organisation_id)
            const localVarPath = `/organisations/{organisation_id}`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisation_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organisations
         * @summary List organisations
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsList: async (page?: OrganisationsListPageParameter, f_name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organisations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                for (const [key, value] of Object.entries(page)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (f_name !== undefined) {
                localVarQueryParameter['f_name'] = f_name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific quota for an organisation
         * @summary Get specific organisation quota
         * @param {string} organisation_id Organisation ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsQuotasGet: async (organisation_id: string, quota_entity_quota: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation_id' is not null or undefined
            assertParamExists('organisationsQuotasGet', 'organisation_id', organisation_id)
            // verify required parameter 'quota_entity_quota' is not null or undefined
            assertParamExists('organisationsQuotasGet', 'quota_entity_quota', quota_entity_quota)
            const localVarPath = `/organisations/{organisation_id}/quotas/{quota_entity_quota}`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisation_id)))
                .replace(`{${"quota_entity_quota"}}`, encodeURIComponent(String(quota_entity_quota)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the quotas for an organisation
         * @summary List organisation quotas
         * @param {string} organisation_id Organisation ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsQuotasList: async (organisation_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation_id' is not null or undefined
            assertParamExists('organisationsQuotasList', 'organisation_id', organisation_id)
            const localVarPath = `/organisations/{organisation_id}/quotas`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisation_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an organisation
         * @summary Update an organisation
         * @param {string} organisation_id Organisation ID reference
         * @param {OrganisationBody} [OrganisationBody] Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsUpdate: async (organisation_id: string, OrganisationBody?: OrganisationBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation_id' is not null or undefined
            assertParamExists('organisationsUpdate', 'organisation_id', organisation_id)
            const localVarPath = `/organisations/{organisation_id}`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisation_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(OrganisationBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationsApi - functional programming interface
 */
export const OrganisationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organisation
         * @summary Create organisations
         * @param {OrganisationBody} [OrganisationBody] Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationsCreate(OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationsCreate(OrganisationBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.organisationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organisation, this will also delete all the resources within the organisation
         * @summary Delete an organisation
         * @param {string} organisation_id Organisation ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationsDelete(organisation_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationsDelete(organisation_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.organisationsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a single organisation
         * @summary Get an organisation
         * @param {string} organisation_id Organisation ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationsGet(organisation_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationsGet(organisation_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.organisationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List organisations
         * @summary List organisations
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationsList(page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organisation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationsList(page, f_name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.organisationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific quota for an organisation
         * @summary Get specific organisation quota
         * @param {string} organisation_id Organisation ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationsQuotasGet(organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationsQuotasGet(organisation_id, quota_entity_quota, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.organisationsQuotasGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the quotas for an organisation
         * @summary List organisation quotas
         * @param {string} organisation_id Organisation ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationsQuotasList(organisation_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationsQuotasList(organisation_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.organisationsQuotasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an organisation
         * @summary Update an organisation
         * @param {string} organisation_id Organisation ID reference
         * @param {OrganisationBody} [OrganisationBody] Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationsUpdate(organisation_id: string, OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationsUpdate(organisation_id, OrganisationBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.organisationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganisationsApi - factory interface
 */
export const OrganisationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationsApiFp(configuration)
    return {
        /**
         * Create an organisation
         * @summary Create organisations
         * @param {OrganisationBody} [OrganisationBody] Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsCreate(OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig): AxiosPromise<Organisation> {
            return localVarFp.organisationsCreate(OrganisationBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organisation, this will also delete all the resources within the organisation
         * @summary Delete an organisation
         * @param {string} organisation_id Organisation ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsDelete(organisation_id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse> {
            return localVarFp.organisationsDelete(organisation_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single organisation
         * @summary Get an organisation
         * @param {string} organisation_id Organisation ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsGet(organisation_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Organisation> {
            return localVarFp.organisationsGet(organisation_id, options).then((request) => request(axios, basePath));
        },
        /**
         * List organisations
         * @summary List organisations
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsList(page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Organisation>> {
            return localVarFp.organisationsList(page, f_name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific quota for an organisation
         * @summary Get specific organisation quota
         * @param {string} organisation_id Organisation ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsQuotasGet(organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>> {
            return localVarFp.organisationsQuotasGet(organisation_id, quota_entity_quota, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the quotas for an organisation
         * @summary List organisation quotas
         * @param {string} organisation_id Organisation ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsQuotasList(organisation_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>> {
            return localVarFp.organisationsQuotasList(organisation_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an organisation
         * @summary Update an organisation
         * @param {string} organisation_id Organisation ID reference
         * @param {OrganisationBody} [OrganisationBody] Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsUpdate(organisation_id: string, OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig): AxiosPromise<Organisation> {
            return localVarFp.organisationsUpdate(organisation_id, OrganisationBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationsApi - object-oriented interface
 */
export class OrganisationsApi extends BaseAPI {
    /**
     * Create an organisation
     * @summary Create organisations
     * @param {OrganisationBody} [OrganisationBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public organisationsCreate(OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).organisationsCreate(OrganisationBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organisation, this will also delete all the resources within the organisation
     * @summary Delete an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public organisationsDelete(organisation_id: string, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).organisationsDelete(organisation_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single organisation
     * @summary Get an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public organisationsGet(organisation_id: string, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).organisationsGet(organisation_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organisations
     * @summary List organisations
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public organisationsList(page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).organisationsList(page, f_name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific quota for an organisation
     * @summary Get specific organisation quota
     * @param {string} organisation_id Organisation ID reference
     * @param {string} quota_entity_quota 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public organisationsQuotasGet(organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).organisationsQuotasGet(organisation_id, quota_entity_quota, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the quotas for an organisation
     * @summary List organisation quotas
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public organisationsQuotasList(organisation_id: string, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).organisationsQuotasList(organisation_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an organisation
     * @summary Update an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {OrganisationBody} [OrganisationBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public organisationsUpdate(organisation_id: string, OrganisationBody?: OrganisationBody, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).organisationsUpdate(organisation_id, OrganisationBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all the projects linked to a specific organisation
         * @summary Get all projects within an organisation
         * @param {string} organisation_id Organisation ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsProjectsList: async (organisation_id: string, page?: OrganisationsListPageParameter, f_name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation_id' is not null or undefined
            assertParamExists('organisationsProjectsList', 'organisation_id', organisation_id)
            const localVarPath = `/organisations/{organisation_id}/projects`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisation_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                for (const [key, value] of Object.entries(page)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (f_name !== undefined) {
                localVarQueryParameter['f_name'] = f_name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new project
         * @summary Create project
         * @param {ProjectBody} [ProjectBody] Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate: async (ProjectBody?: ProjectBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ProjectBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete project, this will also delete all the resources within the project
         * @summary Delete project
         * @param {string} project_id Project ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsDelete: async (project_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsDelete', 'project_id', project_id)
            const localVarPath = `/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific project
         * @summary Get project
         * @param {string} project_id Project ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGet: async (project_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsGet', 'project_id', project_id)
            const localVarPath = `/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all projects for this user, paginated
         * @summary List projects
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsList: async (page?: OrganisationsListPageParameter, f_name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                for (const [key, value] of Object.entries(page)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (f_name !== undefined) {
                localVarQueryParameter['f_name'] = f_name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific quota for a project
         * @summary Get specific project quota
         * @param {string} project_id Project ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsQuotasGet: async (project_id: string, quota_entity_quota: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsQuotasGet', 'project_id', project_id)
            // verify required parameter 'quota_entity_quota' is not null or undefined
            assertParamExists('projectsQuotasGet', 'quota_entity_quota', quota_entity_quota)
            const localVarPath = `/projects/{project_id}/quotas/{quota_entity_quota}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)))
                .replace(`{${"quota_entity_quota"}}`, encodeURIComponent(String(quota_entity_quota)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the quotas for a project
         * @summary List project quotas
         * @param {string} project_id Project ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsQuotasList: async (project_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsQuotasList', 'project_id', project_id)
            const localVarPath = `/projects/{project_id}/quotas`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update project
         * @summary Update project
         * @param {string} project_id Project ID reference
         * @param {ProjectBodyPatch} [ProjectBodyPatch] Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate: async (project_id: string, ProjectBodyPatch?: ProjectBodyPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsUpdate', 'project_id', project_id)
            const localVarPath = `/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ProjectBodyPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all the projects linked to a specific organisation
         * @summary Get all projects within an organisation
         * @param {string} organisation_id Organisation ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationsProjectsList(organisation_id: string, page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationsProjectsList(organisation_id, page, f_name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.organisationsProjectsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new project
         * @summary Create project
         * @param {ProjectBody} [ProjectBody] Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsCreate(ProjectBody?: ProjectBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsCreate(ProjectBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete project, this will also delete all the resources within the project
         * @summary Delete project
         * @param {string} project_id Project ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsDelete(project_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsDelete(project_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific project
         * @summary Get project
         * @param {string} project_id Project ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGet(project_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGet(project_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all projects for this user, paginated
         * @summary List projects
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsList(page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsList(page, f_name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific quota for a project
         * @summary Get specific project quota
         * @param {string} project_id Project ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsQuotasGet(project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsQuotasGet(project_id, quota_entity_quota, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsQuotasGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the quotas for a project
         * @summary List project quotas
         * @param {string} project_id Project ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsQuotasList(project_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsQuotasList(project_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsQuotasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update project
         * @summary Update project
         * @param {string} project_id Project ID reference
         * @param {ProjectBodyPatch} [ProjectBodyPatch] Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsUpdate(project_id: string, ProjectBodyPatch?: ProjectBodyPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsUpdate(project_id, ProjectBodyPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Get all the projects linked to a specific organisation
         * @summary Get all projects within an organisation
         * @param {string} organisation_id Organisation ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsProjectsList(organisation_id: string, page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Project>> {
            return localVarFp.organisationsProjectsList(organisation_id, page, f_name, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new project
         * @summary Create project
         * @param {ProjectBody} [ProjectBody] Create/Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate(ProjectBody?: ProjectBody, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.projectsCreate(ProjectBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete project, this will also delete all the resources within the project
         * @summary Delete project
         * @param {string} project_id Project ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsDelete(project_id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse> {
            return localVarFp.projectsDelete(project_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific project
         * @summary Get project
         * @param {string} project_id Project ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGet(project_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.projectsGet(project_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all projects for this user, paginated
         * @summary List projects
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsList(page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Project>> {
            return localVarFp.projectsList(page, f_name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific quota for a project
         * @summary Get specific project quota
         * @param {string} project_id Project ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsQuotasGet(project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>> {
            return localVarFp.projectsQuotasGet(project_id, quota_entity_quota, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the quotas for a project
         * @summary List project quotas
         * @param {string} project_id Project ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsQuotasList(project_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>> {
            return localVarFp.projectsQuotasList(project_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update project
         * @summary Update project
         * @param {string} project_id Project ID reference
         * @param {ProjectBodyPatch} [ProjectBodyPatch] Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate(project_id: string, ProjectBodyPatch?: ProjectBodyPatch, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.projectsUpdate(project_id, ProjectBodyPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Get all the projects linked to a specific organisation
     * @summary Get all projects within an organisation
     * @param {string} organisation_id Organisation ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public organisationsProjectsList(organisation_id: string, page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).organisationsProjectsList(organisation_id, page, f_name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new project
     * @summary Create project
     * @param {ProjectBody} [ProjectBody] Create/Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsCreate(ProjectBody?: ProjectBody, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsCreate(ProjectBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete project, this will also delete all the resources within the project
     * @summary Delete project
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsDelete(project_id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsDelete(project_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific project
     * @summary Get project
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsGet(project_id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsGet(project_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all projects for this user, paginated
     * @summary List projects
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {string} [f_name] Filter resource on name, if the value ends in an asterix it will be treated as a partial search otherwise, it\&#39;ll be an exact match 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsList(page?: OrganisationsListPageParameter, f_name?: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsList(page, f_name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific quota for a project
     * @summary Get specific project quota
     * @param {string} project_id Project ID reference
     * @param {string} quota_entity_quota 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsQuotasGet(project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsQuotasGet(project_id, quota_entity_quota, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the quotas for a project
     * @summary List project quotas
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsQuotasList(project_id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsQuotasList(project_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update project
     * @summary Update project
     * @param {string} project_id Project ID reference
     * @param {ProjectBodyPatch} [ProjectBodyPatch] Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsUpdate(project_id: string, ProjectBodyPatch?: ProjectBodyPatch, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsUpdate(project_id, ProjectBodyPatch, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvidersApi - axios parameter creator
 */
export const ProvidersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of all providers with their respective deployed regions and cities.
         * @summary Get available providers
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersList: async (page?: OrganisationsListPageParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                for (const [key, value] of Object.entries(page)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvidersApi - functional programming interface
 */
export const ProvidersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvidersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of all providers with their respective deployed regions and cities.
         * @summary Get available providers
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providersList(page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProviderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providersList(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvidersApi.providersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvidersApi - factory interface
 */
export const ProvidersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvidersApiFp(configuration)
    return {
        /**
         * Retrieve a list of all providers with their respective deployed regions and cities.
         * @summary Get available providers
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersList(page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): AxiosPromise<ListProviderResponse> {
            return localVarFp.providersList(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvidersApi - object-oriented interface
 */
export class ProvidersApi extends BaseAPI {
    /**
     * Retrieve a list of all providers with their respective deployed regions and cities.
     * @summary Get available providers
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public providersList(page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig) {
        return ProvidersApiFp(this.configuration).providersList(page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuotasApi - axios parameter creator
 */
export const QuotasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a specific quota for an organisation
         * @summary Get specific organisation quota
         * @param {string} organisation_id Organisation ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsQuotasGet: async (organisation_id: string, quota_entity_quota: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation_id' is not null or undefined
            assertParamExists('organisationsQuotasGet', 'organisation_id', organisation_id)
            // verify required parameter 'quota_entity_quota' is not null or undefined
            assertParamExists('organisationsQuotasGet', 'quota_entity_quota', quota_entity_quota)
            const localVarPath = `/organisations/{organisation_id}/quotas/{quota_entity_quota}`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisation_id)))
                .replace(`{${"quota_entity_quota"}}`, encodeURIComponent(String(quota_entity_quota)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the quotas for an organisation
         * @summary List organisation quotas
         * @param {string} organisation_id Organisation ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsQuotasList: async (organisation_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation_id' is not null or undefined
            assertParamExists('organisationsQuotasList', 'organisation_id', organisation_id)
            const localVarPath = `/organisations/{organisation_id}/quotas`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisation_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific quota for a project
         * @summary Get specific project quota
         * @param {string} project_id Project ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsQuotasGet: async (project_id: string, quota_entity_quota: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsQuotasGet', 'project_id', project_id)
            // verify required parameter 'quota_entity_quota' is not null or undefined
            assertParamExists('projectsQuotasGet', 'quota_entity_quota', quota_entity_quota)
            const localVarPath = `/projects/{project_id}/quotas/{quota_entity_quota}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)))
                .replace(`{${"quota_entity_quota"}}`, encodeURIComponent(String(quota_entity_quota)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the quotas for a project
         * @summary List project quotas
         * @param {string} project_id Project ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsQuotasList: async (project_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsQuotasList', 'project_id', project_id)
            const localVarPath = `/projects/{project_id}/quotas`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific quota for a user
         * @summary Get specific user quota
         * @param {string} user_id User ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersQuotasGet: async (user_id: string, quota_entity_quota: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user_id' is not null or undefined
            assertParamExists('usersQuotasGet', 'user_id', user_id)
            // verify required parameter 'quota_entity_quota' is not null or undefined
            assertParamExists('usersQuotasGet', 'quota_entity_quota', quota_entity_quota)
            const localVarPath = `/users/{user_id}/quotas/{quota_entity_quota}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"quota_entity_quota"}}`, encodeURIComponent(String(quota_entity_quota)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the quotas for a user
         * @summary List user quotas
         * @param {string} user_id User ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersQuotasList: async (user_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user_id' is not null or undefined
            assertParamExists('usersQuotasList', 'user_id', user_id)
            const localVarPath = `/users/{user_id}/quotas`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuotasApi - functional programming interface
 */
export const QuotasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuotasApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a specific quota for an organisation
         * @summary Get specific organisation quota
         * @param {string} organisation_id Organisation ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationsQuotasGet(organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationsQuotasGet(organisation_id, quota_entity_quota, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuotasApi.organisationsQuotasGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the quotas for an organisation
         * @summary List organisation quotas
         * @param {string} organisation_id Organisation ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationsQuotasList(organisation_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationsQuotasList(organisation_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuotasApi.organisationsQuotasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific quota for a project
         * @summary Get specific project quota
         * @param {string} project_id Project ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsQuotasGet(project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsQuotasGet(project_id, quota_entity_quota, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuotasApi.projectsQuotasGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the quotas for a project
         * @summary List project quotas
         * @param {string} project_id Project ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsQuotasList(project_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsQuotasList(project_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuotasApi.projectsQuotasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific quota for a user
         * @summary Get specific user quota
         * @param {string} user_id User ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersQuotasGet(user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersQuotasGet(user_id, quota_entity_quota, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuotasApi.usersQuotasGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the quotas for a user
         * @summary List user quotas
         * @param {string} user_id User ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersQuotasList(user_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersQuotasList(user_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuotasApi.usersQuotasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuotasApi - factory interface
 */
export const QuotasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuotasApiFp(configuration)
    return {
        /**
         * Get a specific quota for an organisation
         * @summary Get specific organisation quota
         * @param {string} organisation_id Organisation ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsQuotasGet(organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>> {
            return localVarFp.organisationsQuotasGet(organisation_id, quota_entity_quota, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the quotas for an organisation
         * @summary List organisation quotas
         * @param {string} organisation_id Organisation ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationsQuotasList(organisation_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>> {
            return localVarFp.organisationsQuotasList(organisation_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific quota for a project
         * @summary Get specific project quota
         * @param {string} project_id Project ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsQuotasGet(project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>> {
            return localVarFp.projectsQuotasGet(project_id, quota_entity_quota, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the quotas for a project
         * @summary List project quotas
         * @param {string} project_id Project ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsQuotasList(project_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>> {
            return localVarFp.projectsQuotasList(project_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific quota for a user
         * @summary Get specific user quota
         * @param {string} user_id User ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersQuotasGet(user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>> {
            return localVarFp.usersQuotasGet(user_id, quota_entity_quota, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the quotas for a user
         * @summary List user quotas
         * @param {string} user_id User ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersQuotasList(user_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>> {
            return localVarFp.usersQuotasList(user_id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuotasApi - object-oriented interface
 */
export class QuotasApi extends BaseAPI {
    /**
     * Get a specific quota for an organisation
     * @summary Get specific organisation quota
     * @param {string} organisation_id Organisation ID reference
     * @param {string} quota_entity_quota 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public organisationsQuotasGet(organisation_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig) {
        return QuotasApiFp(this.configuration).organisationsQuotasGet(organisation_id, quota_entity_quota, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the quotas for an organisation
     * @summary List organisation quotas
     * @param {string} organisation_id Organisation ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public organisationsQuotasList(organisation_id: string, options?: RawAxiosRequestConfig) {
        return QuotasApiFp(this.configuration).organisationsQuotasList(organisation_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific quota for a project
     * @summary Get specific project quota
     * @param {string} project_id Project ID reference
     * @param {string} quota_entity_quota 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsQuotasGet(project_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig) {
        return QuotasApiFp(this.configuration).projectsQuotasGet(project_id, quota_entity_quota, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the quotas for a project
     * @summary List project quotas
     * @param {string} project_id Project ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsQuotasList(project_id: string, options?: RawAxiosRequestConfig) {
        return QuotasApiFp(this.configuration).projectsQuotasList(project_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific quota for a user
     * @summary Get specific user quota
     * @param {string} user_id User ID reference
     * @param {string} quota_entity_quota 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersQuotasGet(user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig) {
        return QuotasApiFp(this.configuration).usersQuotasGet(user_id, quota_entity_quota, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the quotas for a user
     * @summary List user quotas
     * @param {string} user_id User ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersQuotasList(user_id: string, options?: RawAxiosRequestConfig) {
        return QuotasApiFp(this.configuration).usersQuotasList(user_id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecretsApi - axios parameter creator
 */
export const SecretsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new project secret
         * @summary Create project secret
         * @param {string} project_id Project ID reference
         * @param {SecretBody} SecretBody Create/Update any field  The example generated may only be for one of the secret types, look towards the payload section of the schema for further fields, values and examples. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsSecretsCreate: async (project_id: string, SecretBody: SecretBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsSecretsCreate', 'project_id', project_id)
            // verify required parameter 'SecretBody' is not null or undefined
            assertParamExists('projectsSecretsCreate', 'SecretBody', SecretBody)
            const localVarPath = `/projects/{project_id}/secrets`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(SecretBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete project secret, if the secret is still linked to an active/deployed function - it cannot be removed
         * @summary Delete project secret
         * @param {string} project_id Project ID reference
         * @param {string} secret_name Unique secret name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsSecretsDelete: async (project_id: string, secret_name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsSecretsDelete', 'project_id', project_id)
            // verify required parameter 'secret_name' is not null or undefined
            assertParamExists('projectsSecretsDelete', 'secret_name', secret_name)
            const localVarPath = `/projects/{project_id}/secrets/{secret_name}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)))
                .replace(`{${"secret_name"}}`, encodeURIComponent(String(secret_name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific project
         * @summary Get project secret
         * @param {string} project_id Project ID reference
         * @param {string} secret_name Unique secret name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsSecretsGet: async (project_id: string, secret_name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsSecretsGet', 'project_id', project_id)
            // verify required parameter 'secret_name' is not null or undefined
            assertParamExists('projectsSecretsGet', 'secret_name', secret_name)
            const localVarPath = `/projects/{project_id}/secrets/{secret_name}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)))
                .replace(`{${"secret_name"}}`, encodeURIComponent(String(secret_name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project secrets of a specific type
         * @summary List project secrets of a specific type
         * @param {string} project_id Project ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {SecretMetaType} [secret_type] Type of secret to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsSecretsList: async (project_id: string, page?: OrganisationsListPageParameter, secret_type?: SecretMetaType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsSecretsList', 'project_id', project_id)
            const localVarPath = `/projects/{project_id}/secrets`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                for (const [key, value] of Object.entries(page)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (secret_type !== undefined) {
                localVarQueryParameter['secret_type'] = secret_type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update project
         * @summary Update project secret
         * @param {string} project_id Project ID reference
         * @param {string} secret_name Unique secret name
         * @param {SecretBodyPatch} SecretBodyPatch Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsSecretsUpdate: async (project_id: string, secret_name: string, SecretBodyPatch: SecretBodyPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project_id' is not null or undefined
            assertParamExists('projectsSecretsUpdate', 'project_id', project_id)
            // verify required parameter 'secret_name' is not null or undefined
            assertParamExists('projectsSecretsUpdate', 'secret_name', secret_name)
            // verify required parameter 'SecretBodyPatch' is not null or undefined
            assertParamExists('projectsSecretsUpdate', 'SecretBodyPatch', SecretBodyPatch)
            const localVarPath = `/projects/{project_id}/secrets/{secret_name}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(project_id)))
                .replace(`{${"secret_name"}}`, encodeURIComponent(String(secret_name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(SecretBodyPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecretsApi - functional programming interface
 */
export const SecretsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecretsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new project secret
         * @summary Create project secret
         * @param {string} project_id Project ID reference
         * @param {SecretBody} SecretBody Create/Update any field  The example generated may only be for one of the secret types, look towards the payload section of the schema for further fields, values and examples. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsSecretsCreate(project_id: string, SecretBody: SecretBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsSecretsCreate(project_id, SecretBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.projectsSecretsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete project secret, if the secret is still linked to an active/deployed function - it cannot be removed
         * @summary Delete project secret
         * @param {string} project_id Project ID reference
         * @param {string} secret_name Unique secret name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsSecretsDelete(project_id: string, secret_name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsSecretsDelete(project_id, secret_name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.projectsSecretsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific project
         * @summary Get project secret
         * @param {string} project_id Project ID reference
         * @param {string} secret_name Unique secret name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsSecretsGet(project_id: string, secret_name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsSecretsGet(project_id, secret_name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.projectsSecretsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List project secrets of a specific type
         * @summary List project secrets of a specific type
         * @param {string} project_id Project ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {SecretMetaType} [secret_type] Type of secret to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsSecretsList(project_id: string, page?: OrganisationsListPageParameter, secret_type?: SecretMetaType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Secret>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsSecretsList(project_id, page, secret_type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.projectsSecretsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update project
         * @summary Update project secret
         * @param {string} project_id Project ID reference
         * @param {string} secret_name Unique secret name
         * @param {SecretBodyPatch} SecretBodyPatch Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsSecretsUpdate(project_id: string, secret_name: string, SecretBodyPatch: SecretBodyPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsSecretsUpdate(project_id, secret_name, SecretBodyPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.projectsSecretsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecretsApi - factory interface
 */
export const SecretsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecretsApiFp(configuration)
    return {
        /**
         * Create a new project secret
         * @summary Create project secret
         * @param {string} project_id Project ID reference
         * @param {SecretBody} SecretBody Create/Update any field  The example generated may only be for one of the secret types, look towards the payload section of the schema for further fields, values and examples. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsSecretsCreate(project_id: string, SecretBody: SecretBody, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.projectsSecretsCreate(project_id, SecretBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete project secret, if the secret is still linked to an active/deployed function - it cannot be removed
         * @summary Delete project secret
         * @param {string} project_id Project ID reference
         * @param {string} secret_name Unique secret name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsSecretsDelete(project_id: string, secret_name: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse> {
            return localVarFp.projectsSecretsDelete(project_id, secret_name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific project
         * @summary Get project secret
         * @param {string} project_id Project ID reference
         * @param {string} secret_name Unique secret name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsSecretsGet(project_id: string, secret_name: string, options?: RawAxiosRequestConfig): AxiosPromise<SecretMeta> {
            return localVarFp.projectsSecretsGet(project_id, secret_name, options).then((request) => request(axios, basePath));
        },
        /**
         * List project secrets of a specific type
         * @summary List project secrets of a specific type
         * @param {string} project_id Project ID reference
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {SecretMetaType} [secret_type] Type of secret to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsSecretsList(project_id: string, page?: OrganisationsListPageParameter, secret_type?: SecretMetaType, options?: RawAxiosRequestConfig): AxiosPromise<Array<Secret>> {
            return localVarFp.projectsSecretsList(project_id, page, secret_type, options).then((request) => request(axios, basePath));
        },
        /**
         * Update project
         * @summary Update project secret
         * @param {string} project_id Project ID reference
         * @param {string} secret_name Unique secret name
         * @param {SecretBodyPatch} SecretBodyPatch Update any field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsSecretsUpdate(project_id: string, secret_name: string, SecretBodyPatch: SecretBodyPatch, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.projectsSecretsUpdate(project_id, secret_name, SecretBodyPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecretsApi - object-oriented interface
 */
export class SecretsApi extends BaseAPI {
    /**
     * Create a new project secret
     * @summary Create project secret
     * @param {string} project_id Project ID reference
     * @param {SecretBody} SecretBody Create/Update any field  The example generated may only be for one of the secret types, look towards the payload section of the schema for further fields, values and examples. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsSecretsCreate(project_id: string, SecretBody: SecretBody, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).projectsSecretsCreate(project_id, SecretBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete project secret, if the secret is still linked to an active/deployed function - it cannot be removed
     * @summary Delete project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsSecretsDelete(project_id: string, secret_name: string, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).projectsSecretsDelete(project_id, secret_name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific project
     * @summary Get project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsSecretsGet(project_id: string, secret_name: string, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).projectsSecretsGet(project_id, secret_name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List project secrets of a specific type
     * @summary List project secrets of a specific type
     * @param {string} project_id Project ID reference
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {SecretMetaType} [secret_type] Type of secret to filter on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsSecretsList(project_id: string, page?: OrganisationsListPageParameter, secret_type?: SecretMetaType, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).projectsSecretsList(project_id, page, secret_type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update project
     * @summary Update project secret
     * @param {string} project_id Project ID reference
     * @param {string} secret_name Unique secret name
     * @param {SecretBodyPatch} SecretBodyPatch Update any field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsSecretsUpdate(project_id: string, secret_name: string, SecretBodyPatch: SecretBodyPatch, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).projectsSecretsUpdate(project_id, secret_name, SecretBodyPatch, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokensApi - axios parameter creator
 */
export const TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new auth token for use with the CLI and TF Provider  ### Warning The `token` field is only shown once and can\'t be retrieved again without generating a new token. Securely save this once the response has been received. 
         * @summary Create new auth token
         * @param {AuthTokenBody} AuthTokenBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensCreate: async (AuthTokenBody: AuthTokenBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'AuthTokenBody' is not null or undefined
            assertParamExists('authTokensCreate', 'AuthTokenBody', AuthTokenBody)
            const localVarPath = `/auth/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(AuthTokenBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete token
         * @param {string} token_id Token ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensDelete: async (token_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token_id' is not null or undefined
            assertParamExists('authTokensDelete', 'token_id', token_id)
            const localVarPath = `/auth/tokens/{token_id}`
                .replace(`{${"token_id"}}`, encodeURIComponent(String(token_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get token information
         * @param {string} token_id Token ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensGet: async (token_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token_id' is not null or undefined
            assertParamExists('authTokensGet', 'token_id', token_id)
            const localVarPath = `/auth/tokens/{token_id}`
                .replace(`{${"token_id"}}`, encodeURIComponent(String(token_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all user auth tokens
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensList: async (page?: OrganisationsListPageParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                for (const [key, value] of Object.entries(page)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update token
         * @param {string} token_id Token ID reference
         * @param {AuthTokenPatch} AuthTokenPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensUpdate: async (token_id: string, AuthTokenPatch: AuthTokenPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token_id' is not null or undefined
            assertParamExists('authTokensUpdate', 'token_id', token_id)
            // verify required parameter 'AuthTokenPatch' is not null or undefined
            assertParamExists('authTokensUpdate', 'AuthTokenPatch', AuthTokenPatch)
            const localVarPath = `/auth/tokens/{token_id}`
                .replace(`{${"token_id"}}`, encodeURIComponent(String(token_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(AuthTokenPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 */
export const TokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new auth token for use with the CLI and TF Provider  ### Warning The `token` field is only shown once and can\'t be retrieved again without generating a new token. Securely save this once the response has been received. 
         * @summary Create new auth token
         * @param {AuthTokenBody} AuthTokenBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokensCreate(AuthTokenBody: AuthTokenBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokensCreate(AuthTokenBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.authTokensCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete token
         * @param {string} token_id Token ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokensDelete(token_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokensDelete(token_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.authTokensDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get token information
         * @param {string} token_id Token ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokensGet(token_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokensGet(token_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.authTokensGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all user auth tokens
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokensList(page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthTokenMeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokensList(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.authTokensList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update token
         * @param {string} token_id Token ID reference
         * @param {AuthTokenPatch} AuthTokenPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokensUpdate(token_id: string, AuthTokenPatch: AuthTokenPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokensUpdate(token_id, AuthTokenPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.authTokensUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TokensApi - factory interface
 */
export const TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokensApiFp(configuration)
    return {
        /**
         * Create new auth token for use with the CLI and TF Provider  ### Warning The `token` field is only shown once and can\'t be retrieved again without generating a new token. Securely save this once the response has been received. 
         * @summary Create new auth token
         * @param {AuthTokenBody} AuthTokenBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensCreate(AuthTokenBody: AuthTokenBody, options?: RawAxiosRequestConfig): AxiosPromise<AuthToken> {
            return localVarFp.authTokensCreate(AuthTokenBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete token
         * @param {string} token_id Token ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensDelete(token_id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletedResponse> {
            return localVarFp.authTokensDelete(token_id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get token information
         * @param {string} token_id Token ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensGet(token_id: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthTokenMeta> {
            return localVarFp.authTokensGet(token_id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all user auth tokens
         * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensList(page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<AuthTokenMeta>> {
            return localVarFp.authTokensList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update token
         * @param {string} token_id Token ID reference
         * @param {AuthTokenPatch} AuthTokenPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensUpdate(token_id: string, AuthTokenPatch: AuthTokenPatch, options?: RawAxiosRequestConfig): AxiosPromise<AuthToken> {
            return localVarFp.authTokensUpdate(token_id, AuthTokenPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokensApi - object-oriented interface
 */
export class TokensApi extends BaseAPI {
    /**
     * Create new auth token for use with the CLI and TF Provider  ### Warning The `token` field is only shown once and can\'t be retrieved again without generating a new token. Securely save this once the response has been received. 
     * @summary Create new auth token
     * @param {AuthTokenBody} AuthTokenBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authTokensCreate(AuthTokenBody: AuthTokenBody, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).authTokensCreate(AuthTokenBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete token
     * @param {string} token_id Token ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authTokensDelete(token_id: string, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).authTokensDelete(token_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get token information
     * @param {string} token_id Token ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authTokensGet(token_id: string, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).authTokensGet(token_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all user auth tokens
     * @param {OrganisationsListPageParameter} [page] Query parameters for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authTokensList(page?: OrganisationsListPageParameter, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).authTokensList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update token
     * @param {string} token_id Token ID reference
     * @param {AuthTokenPatch} AuthTokenPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authTokensUpdate(token_id: string, AuthTokenPatch: AuthTokenPatch, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).authTokensUpdate(token_id, AuthTokenPatch, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a specific quota for a user
         * @summary Get specific user quota
         * @param {string} user_id User ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersQuotasGet: async (user_id: string, quota_entity_quota: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user_id' is not null or undefined
            assertParamExists('usersQuotasGet', 'user_id', user_id)
            // verify required parameter 'quota_entity_quota' is not null or undefined
            assertParamExists('usersQuotasGet', 'quota_entity_quota', quota_entity_quota)
            const localVarPath = `/users/{user_id}/quotas/{quota_entity_quota}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"quota_entity_quota"}}`, encodeURIComponent(String(quota_entity_quota)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the quotas for a user
         * @summary List user quotas
         * @param {string} user_id User ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersQuotasList: async (user_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user_id' is not null or undefined
            assertParamExists('usersQuotasList', 'user_id', user_id)
            const localVarPath = `/users/{user_id}/quotas`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a specific quota for a user
         * @summary Get specific user quota
         * @param {string} user_id User ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersQuotasGet(user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersQuotasGet(user_id, quota_entity_quota, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersQuotasGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the quotas for a user
         * @summary List user quotas
         * @param {string} user_id User ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersQuotasList(user_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersQuotasList(user_id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersQuotasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Get a specific quota for a user
         * @summary Get specific user quota
         * @param {string} user_id User ID reference
         * @param {string} quota_entity_quota 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersQuotasGet(user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>> {
            return localVarFp.usersQuotasGet(user_id, quota_entity_quota, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the quotas for a user
         * @summary List user quotas
         * @param {string} user_id User ID reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersQuotasList(user_id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quota>> {
            return localVarFp.usersQuotasList(user_id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * Get a specific quota for a user
     * @summary Get specific user quota
     * @param {string} user_id User ID reference
     * @param {string} quota_entity_quota 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersQuotasGet(user_id: string, quota_entity_quota: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersQuotasGet(user_id, quota_entity_quota, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the quotas for a user
     * @summary List user quotas
     * @param {string} user_id User ID reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersQuotasList(user_id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersQuotasList(user_id, options).then((request) => request(this.axios, this.basePath));
    }
}



